<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Python</title><link rel="stylesheet" href="qtiplot.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.68.1"><meta name="keywords" content="QT, Qtiplot, Data, Analysis, Plotting"><link rel="start" href="index.html" title="The QtiPlot Handbook"><link rel="up" href="scripting.html" title="Chapter 7. Mathematical Expressions and Scripting"><link rel="prev" href="scripting.html" title="Chapter 7. Mathematical Expressions and Scripting"><link rel="next" href="credits.html" title="Chapter 8. Credits and License"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Python</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="scripting.html">Prev</a> </td><th width="60%" align="center">Chapter 7. Mathematical Expressions and Scripting</th><td width="20%" align="right"> <a accesskey="n" href="credits.html">Next</a></td></tr></table><hr></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Python"></a>Python</h2></div></div></div><p>This module provides bindings to the <a href="http://www.python.org" target="_top">Python</a> programming language. Basic
    usage in the context of QtiPlot will be discussed below, but for more
    in-depth information on the language itself, please refer to its excellent
    <a href="http://www.python.org/doc" target="_top">documentation</a>.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="Python-init"></a>The Initialization File</h3></div></div></div><p>This file allows you to customize the Python environment, import
      modules and define functions and classes that will be available in all
      of your projects. The default initialization file shipped with QtiPlot
      imports Python's <a href="Python.html#Python-functions" title="Mathematical Functions">standard math
      functions</a> as well as special functions from <a href="http://www.scipy.org" target="_top">SciPy</a> (if available). Also, it
      creates some handy shortcuts, like
      <strong class="userinput"><code>table("table1")</code></strong> for
      <strong class="userinput"><code>qti.app.table("table1")</code></strong>.</p><p>When activating Python support, QtiPlot searches the following
      places, executing the first file it can find:</p><div class="orderedlist"><ol type="1"><li><p>~/.qtiplotrc.py[c]</p></li><li><p>/etc/qtiplotrc.py[c]</p></li><li><p>./qtiplotrc.py[c]</p></li></ol></div><p>Files ending in .pyc are compiled versions of the .py source files
      and therefore load a bit faster. The compiled version will be used if
      the source file is older or nonexistent. Otherwise, QtiPlot will try to
      compile the source file (if you've got write permissions for the output
      file).</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="id2561683"></a>Python Basics</h3></div></div></div><p>Mathematical expressions work largely as expected. However,
      there's one caveat, especially when switching from muParser (which has
      been used exclusively in previous versions of QtiPlot):
      <strong class="userinput"><code>a^b</code></strong> does not mean "raise a to the power of b" but
      rather "bitwise exclusive or of a and b"; Python's power operator is **.
      Thus: </p><pre class="screen">
<strong class="userinput"><code>2^3 # read: 10 xor 11 = 01</code></strong>
<code class="computeroutput">#&gt; 1</code>
<strong class="userinput"><code>2**3</code></strong>
<code class="computeroutput">#&gt; 8</code>
</pre><p>One thing you have to know when working with Python is that
      indentation is very important. It is used for grouping (most other
      languages use either braces or keywords like
      <strong class="userinput"><code>do...end</code></strong> for this). For example, </p><pre class="programlisting">
x=23
for i in (1,4,5):
	x=i**2
	print(x)
	</pre><p> will do what you would expect: it prints out the numbers 1, 16 and
      25; each on a line of its own. Deleting just a bit of space will change
      the functionality of your program: </p><pre class="programlisting">
x=23
for i in (1,4,5):
	x=i**2
print(x)
	</pre><p> will print out only one number - no, not 23, but rather 25. This
      example was designed to also teach you something about variable scoping:
      There are no block-local variables in Python.</p><p>There are two different variable scopes to be aware of: local and
      global variables. Unless specified otherwise, variables are local to the
      context in which they were defined. Thus, the variable
      <code class="varname">x</code> can have three different values in, say, two
      different Note windows and a column formula. Global variables on the
      other hand can be accessed from everywhere within your project. A
      variable <code class="varname">x</code> is declared global by executing the
      statement <strong class="userinput"><code>global x</code></strong>. You have to do this before
      assigning a value to <code class="varname">x</code>, but you have to do it only
      once within the project (no need to "import" the variable before using
      it). Note that there is a slight twist to these rules when you <a href="Python.html#Python-def" title="Defining Functions and Control Flow">define your own functions</a>.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="Python-def"></a>Defining Functions and Control Flow</h3></div></div></div><p>The basic syntax for defining a function (for use within one
      particular note, for example) is </p><pre class="programlisting">
def answer():
	return 42
	</pre><p> If you want your function to be accessible from the rest of your
      project, you have to declare it global before the definition: </p><pre class="programlisting">
global answer
def answer():
	return 42
	</pre><p> You can add your own function to QtiPlot's function list. We'll
      also provide a documentation string that will show up, for example, in
      the "set column values" dialog: </p><pre class="programlisting">
global answer
def answer():
	"Return the answer to the ultimate question about life, the universe and everything."
	return 42
qti.mathFunctions["answer"] = answer
	</pre><p> If you want to remove a function from the list, do: </p><pre class="programlisting">
del qti.mathFunctions["answer"]
	</pre><p>Note that functions have their own local scope. That means that if
      you enter a function definition in a Note, you will not be able to
      access (neither reading nor writing) Note-local variables from within
      the function. However, you can access global variables as usual.</p><p>If-then-else decisions are entered as follows: </p><pre class="programlisting">
if x&gt;23:
	print(x)
else:
	print("The value is too small.")
	</pre><p>You can do loops, too: </p><pre class="programlisting">
for i in range(1, 11):
	print(i)
	</pre><p> This will print out the numbers between 1 and 10 inclusively (the
      upper limit does not belong to the range, while the lower limit
      does).</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="Python-functions"></a>Mathematical Functions</h3></div></div></div><p>Python comes with some basic mathematical functions that are
      automatically imported (if you use the <a href="Python.html#Python-init" title="The Initialization File">initialization file</a> shipped with QtiPlot).
      Along with them, the constants e (Euler's number) and pi (the one and
      only) are defined.</p><div class="table"><a name="id2561927"></a><p class="title"><b>Table 7.3. Supported Mathematical Functions</b></p><table summary="Supported Mathematical Functions" width="100%" border="1"><colgroup><col align="left"><col align="justify"></colgroup><thead><tr><th align="left">Name</th><th align="justify">Description</th></tr></thead><tbody><tr><td align="left">acos(x)</td><td align="justify">inverse cosinus</td></tr><tr><td align="left">asin(x)</td><td align="justify">inverse sinus</td></tr><tr><td align="left">atan(x)</td><td align="justify">inverse tangent</td></tr><tr><td align="left">atan2(y,x)</td><td align="justify">equivalent to atan(y/x), but more efficient</td></tr><tr><td align="left">ceil(x)</td><td align="justify">ceiling; smallest integer greater or equal to x</td></tr><tr><td align="left">cos(x)</td><td align="justify">cosinus of x</td></tr><tr><td align="left">cosh(x)</td><td align="justify">hyperbolic cosinus of x</td></tr><tr><td align="left">degrees(x)</td><td align="justify">convert angle from radians to degrees</td></tr><tr><td align="left">exp(x)</td><td align="justify">Exponential function: e raised to the power of x.</td></tr><tr><td align="left">fabs(x)</td><td align="justify">absolute value of x</td></tr><tr><td align="left">floor(x)</td><td align="justify">largest integer smaller or equal to x</td></tr><tr><td align="left">fmod(x,y)</td><td align="justify">remainder of integer division x/y</td></tr><tr><td align="left">frexp(x)</td><td align="justify">Returns the tuple (mantissa,exponent) such that
              x=mantissa*(2**exponent) where exponent is an integer and 0.5
              &lt;=abs(m)&lt;1.0</td></tr><tr><td align="left">hypot(x,y)</td><td align="justify">equivalent to sqrt(x*x+y*y)</td></tr><tr><td align="left">ldexp(x,y)</td><td align="justify">equivalent to x*(2**y)</td></tr><tr><td align="left">log(x)</td><td align="justify">natural (base e) logarythm of x</td></tr><tr><td align="left">log10(x)</td><td align="justify">decimal (base 10) logarythm of x</td></tr><tr><td align="left">modf(x)</td><td align="justify">return fractional and integer part of x as a
              tuple</td></tr><tr><td align="left">pow(x,y)</td><td align="justify">x to the power of y; equivalent to x**y</td></tr><tr><td align="left">radians(x)</td><td align="justify">convert angle from degrees to radians</td></tr><tr><td align="left">sin(x)</td><td align="justify">sinus of x</td></tr><tr><td align="left">sinh(x)</td><td align="justify">hyperblic sinus of x</td></tr><tr><td align="left">sqrt(x)</td><td align="justify">square root of x</td></tr><tr><td align="left">tan(x)</td><td align="justify">tangent of x</td></tr><tr><td align="left">tanh(x)</td><td align="justify">hyperbolic tangent of x</td></tr></tbody></table></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="Python-API"></a>Accessing QtiPlot's functions from Python</h3></div></div></div><p>We will assume that you are using the <a href="Python.html#Python-init" title="The Initialization File">initialization file</a> shipped with
      QtiPlot.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id2562268"></a>Establishing contact</h4></div></div></div><p>Accessing the objects in your project is straight-forward,
        </p><pre class="programlisting">
t = table("Table1")
m = matrix("Matrix1")
g = graph("Graph1")
n = note("Notes1")
	  </pre><p> as is creating new objects: </p><pre class="programlisting">
# create an empty table named "tony" with 5 rows and 2 columns:
t = newTable("tony", 5, 2)
# use defaults
t = newTable()
# create an empty matrix named "gina" with 42 rows and 23 columns:
m = newMatrix("gina", 42, 23)
# use defaults
m = newMatrix()
# create an empty graph window
g = newGraph()
# create an empty note named "momo"
n = note("momo")
# use defaults
n = note()
	  </pre><p>
	    New objects will always be added to the active folder.
	    The functions table, matrix, graph and note will start searching in the active folder and, failing this, continue with a depth-first recursive search of the project's root folder.
	    In order to access other folders, there are the functions
	    </p><pre class="programlisting">
f = activeFolder()
# and
f = rootFolder()
</pre><p>
	    which can be used to access subfolders and windows:
	    </p><pre class="programlisting">
f2 = f.folders()[number]
f2 = f.folder(name, caseSensitive=True, partialMatch=False)
t = f.table(name, recursive=False)
m = f.matrix(name, recursive=False)
g = f.graph(name, recursive=False)
n = f.note(name, recursive=False)
</pre><p>
            If you supply True for the recursive argument, a depth-first recursive search of all subfolders will be performed and the first match returned.</p><p>Also, every piece of code is executed in the context of an
	  object which you can access via the <code class="varname">self</code> variable. For example,
        entering <strong class="userinput"><code>self.cell("t",i)</code></strong> as a column formula
        is equivalent to the convenience function
        <strong class="userinput"><code>col("t")</code></strong>.</p></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id2562357"></a>Working with Tables</h4></div></div></div><p>We'll assume that you have assigned some table to the variable
        <code class="varname">t</code>. You can access its numeric cell values with
        </p><pre class="programlisting">
t.cell(col, row)
# and
t.setCell(col, row, value)
	  </pre><p> Whenever you have to specify a column, you can use either the
        column name (as a string) or the consecutive column number (starting
        with 1). Row numbers also start with 1, just as they are displayed. If
        you want to work with arbitrary texts or the textual representations
        of numeric values, you can use </p><pre class="programlisting">
t.text(col, row)
# and
t.setText(col, row, string)
	  </pre><p> The number of columns and rows is accessed via </p><pre class="programlisting">
t.numRows()
t.numCols()
t.setNumRows(number)
t.setNumCols(number)
	  </pre><p> Column names can be read and written with </p><pre class="programlisting">
t.colName(number)
t.setColName(col, newName)
	  </pre><p> Normalize a single or all columns: </p><pre class="programlisting">
t.normalize(col)
t.normalize()
	  </pre><p> Import values from <code class="varname">file</code>, using
        <code class="varname">sep</code> as separator char and ignoring
        <code class="varname">ignore</code> lines at the head of the file. The flags
        should be self-explanatory. </p><pre class="programlisting">
t.importASCII(file, sep="\t", ignore=0, renameCols=False, stripSpaces=True, simplifySpace=False, newTable=False)
	  </pre><p> After having changed some table values from a script, you will
        likely want to update dependent Graphs: </p><pre class="programlisting">
t.notifyChanges()
	  </pre><p>As a simple example, let's set some column values without using
        the dialog. </p><pre class="programlisting">
t = table("table1")
for i in range(1, t.numRows()+1):
	t.setCell(1, i, i**2)
t.notifyChanges()
	  </pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id2562469"></a>Working with Matrices</h4></div></div></div><p>We'll assume that you have assigned some matrix to the variable
        <code class="varname">m</code>. Accessing cell values is very similar to Table,
        but since Matrix doesn't use column logic, row arguments are specified
        before columns and obviously you can't use column name. </p><pre class="programlisting">
m.cell(row, col)
m.setCell(row, col, value)
m.text(row, col)
m.setText(row, col, string)
	  </pre><p> Also like with tables, there's </p><pre class="programlisting">
m.numRows()
# and
m.numCols()
	  </pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id2562505"></a>Plotting and Working with Graphs</h4></div></div></div><p>If you want to create a new Graph window for some data in table
        table1, you can use the plot command: </p><pre class="programlisting">
g = plot(table, column, type)
	  </pre><p> <code class="varname">type</code> is a number between 0 and 10 and
        specifies the desired plot type: </p><div class="variablelist"><dl><dt><span class="term">0.</span></dt><dd><p>Line</p></dd><dt><span class="term">1.</span></dt><dd><p>Symbols</p></dd><dt><span class="term">2.</span></dt><dd><p>Line and Symbols</p></dd><dt><span class="term">3.</span></dt><dd><p>Columns</p></dd><dt><span class="term">4.</span></dt><dd><p>Area</p></dd><dt><span class="term">5.</span></dt><dd><p>Pie</p></dd><dt><span class="term">6.</span></dt><dd><p>Vertical drop lines</p></dd><dt><span class="term">7.</span></dt><dd><p>Splines and Symbols</p></dd><dt><span class="term">8.</span></dt><dd><p>Vertical steps</p></dd><dt><span class="term">9.</span></dt><dd><p>Histogram</p></dd><dt><span class="term">10.</span></dt><dd><p>Rows</p></dd></dl></div><p> You can plot more than one column at once by giving
        a Python tuple (see the <a href="http://docs.python.org/tut" target="_top">Python
        Tutorial</a>) as an argument: </p><pre class="programlisting">
g = plot(table("table1"), (2,4,7), 2)
	  </pre><p>If you want to add a curve to an existing Graph window, you have
        to choose the destination layer. Usually, </p><pre class="programlisting">
l = g.activeLayer()
	  </pre><p> will do the trick, but you can also select a layer by its number:
        </p><pre class="programlisting">
l = g.layer(num)
	  </pre><p> You can then add or remove curves to or from this layer: </p><pre class="programlisting">
l.insertCurve(table, column, type=1)
l.insertCurve(table, Xcolumn, Ycolumn, type=1)
l.removeCurve(curveName)
l.removeCurve(curveNumber)
l.deleteFitCurves()
	  </pre><p> In case you need the number of curves on a layer, you can get it
        with </p><pre class="programlisting">
l.numCurves()
	  </pre><p>Layers and whole Graphs can be printed and exported from within
        Python. Before you do this, you would probably want to change layer and axis
        titles as well as legend texts: </p><pre class="programlisting">
l.setTitle(title)
l.setXTitle(Xtitle)
l.setYTitle(Ytitle)
l.setLegend(text)
	  </pre><p> You can also customize the scales of the different axes using: </p><pre class="programlisting">
l.setScale(int axis, double start, double end, double step=0.0, int majorTicks=5, int minorTicks=5, int type=0, bool inverted=False);
</pre><p>
	  where <code class="varname">axis</code> is a number between 0 and 3 with the following signification: </p><div class="variablelist"><dl><dt><span class="term">0.</span></dt><dd><p>Left axis</p></dd><dt><span class="term">1.</span></dt><dd><p>Right axis</p></dd><dt><span class="term">2.</span></dt><dd><p>Bottom axis</p></dd><dt><span class="term">3.</span></dt><dd><p>Top axis</p></dd></dl></div><p>
<code class="varname">type</code> specifies the desired scale type: </p><div class="variablelist"><dl><dt><span class="term">0.</span></dt><dd><p>Linear</p></dd><dt><span class="term">1.</span></dt><dd><p>Log10</p></dd></dl></div><p>
	  and <code class="varname">step</code> defines the size of the interval between the major scale ticks. If not specified (default value is 0.0), the step size is calculated automatically.
	  The other flags should be self-explanatory.
	  Now, here is how you can export a layer </p><pre class="programlisting">
l.print()
l.exportToSVG(filename)
l.exportToEPS(filename)
l.exportImage(filename, filetype="PNG", quality=100, transparent=False)
	  </pre><p> and a graph </p><pre class="programlisting">
g.print()
g.exportToSVG(filename)
g.exportToEPS(filename)
	  </pre></div><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="id2562898"></a>Fitting</h4></div></div></div><p>Assuming you have a Graph named "graph1" with a curve entitled
        "table1_2" (on its active layer), a minimal Fit example would be:
        </p><pre class="programlisting">
f = GaussFit(graph("graph1").activeLayer(), "table1_2")
f.guessInitialValues()
f.fit()
	  </pre><p> This creates a new GaussFit object on the curve, lets it guess
        the start parameters and does the fit. The following fit types are
        supported: </p><div class="itemizedlist"><ul type="disc"><li><p>LinearFit(layer, curve)</p></li><li><p>PolynomialFit(layer, curve, degree=2, legend=False)</p></li><li><p>ExponentialFit(layer, curve, growth=False)</p></li><li><p>TwoExpFit(layer, curve)</p></li><li><p>ThreeExpFit(layer, curve)</p></li><li><p>GaussFit(layer, curve)</p></li><li><p>GaussAmpFit(layer, curve)</p></li><li><p>LorentzFit(layer,curve)</p></li><li><p>SigmoidalFit(layer, curve)</p></li><li><p>NonLinearFit(layer, curve)</p><pre class="programlisting">
f = NonLinearFit(layer, curve)
f.setParameters(name1, ...)
f.setFormula(formula_string)
		    </pre></li><li><p>PluginFit(layer, curve)</p><pre class="programlisting">
f = PluginFit(layer, curve)
f.load(pluginName)
		    </pre></li></ul></div><p> For each of these, you can optionally restrict the X
        range that will be used for the fit, like in </p><pre class="programlisting">
f = LinearFit(graph("graph1").activeLayer(), "table1_2", 2, 7)
f.fit()
	  </pre><p>After creating the Fit object and before calling its fit()
        method, you can set a number of parameters that influence the fit:
        </p><pre class="programlisting">
f.setDataFromCurve(curve)			<em class="lineannotation"><span class="lineannotation">change data source</span></em>
f.setDataFromCurve(curve, graph)		<em class="lineannotation"><span class="lineannotation">change data source</span></em>
f.setDataFromCurve(curve, from, to)		<em class="lineannotation"><span class="lineannotation">change data source</span></em>
f.setDataFromCurve(curve, from, to, graph)	<em class="lineannotation"><span class="lineannotation">change data source</span></em>
f.setInterval(from, to)				<em class="lineannotation"><span class="lineannotation">change data range</span></em>
f.setInitialValue(number, value)
f.setInitialValues(value1, ...)
f.guessInitialValues()
f.setAlgorithm(algo) # algo = Fit.ScaledLevenbergMarquardt, Fit.UnscaledLevenbergMarquardt, Fit.NelderMeadSimplex
f.setWeightingData(method, colname) # method = Fit.NoWeighting, Fit.Instrumental, Fit.Statistical, Fit.Dataset
f.setTolerance(tolerance)
f.setOutputPrecision(precision)
f.setMaximumIterations(number)
f.scaleErrors(yes = True)
f.setColor(qt.QColor("green"))			<em class="lineannotation"><span class="lineannotation">change the color of the result fit curve to green (default color is red)</span></em>
	  </pre><p>After you've called fit(), you have a number of possibilities
        for extracting the results: </p><pre class="programlisting">
f.results()
f.errors()
f.chiSquare()
f.rSquare()
f.dataSize()
f.numParameters()
f.parametersTable("params")
f.covarianceMatrix("cov")
	  </pre></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="scripting.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="scripting.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="credits.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 7. Mathematical Expressions and Scripting </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 8. Credits and License</td></tr></table></div></body></html>
