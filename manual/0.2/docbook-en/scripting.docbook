<title>Mathematical Expressions and Scripting</title>
<indexterm><primary>Scripting</primary></indexterm>

  <para>&appname; supports different interpreters
  for evaluating mathematical expressions and for executing scripts.</para>

  <sect1 id="sec-muParser">
    <title>muParser</title>
    <indexterm><primary>Scripting</primary><secondary>MuParser</secondary></indexterm>
    <para>The constants _e=e=E and _pi=pi=PI=Pi are defined, as well as the
		 operators and functions listed below. muParser is purely a parser for mathematical
		 expressions and as such does not support executing complex scripts. However,
		 you can make formulas easier to read and modify by assigning subexpressions to
		 variables and inserting comments.
	 </para>
	 <para><emphasis>Variable assignments</emphasis> evaluate to the assigned value, so
		 they can be used in the middle of a formula. They can also stand on a line of
		 their own, or separated from other parts of the formula by a semicolon (;).
		 The result of evaluating the last line of a multi-line formula is taken as the
		 result of the whole formula.
	 </para>
	 <para><emphasis>Comments</emphasis> start with a hash mark (#) and run till the end
		 of the line.</para>

    <table frame="sides" pgwide="1" tocentry="1">
      <title>Supported Mathematical Operators</title>

      <tgroup cols="2">
        <colspec align="left" colname="name" colwidth="1*" />

        <colspec align="justify" colname="description" colwidth="10*" />

        <thead>
          <row>
            <entry>Name</entry>

            <entry>Description</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry>+</entry>

            <entry>Addition</entry>
          </row>

          <row>
            <entry>-</entry>

            <entry>Substraction</entry>
          </row>

          <row>
            <entry>*</entry>

            <entry>Multiplication</entry>
          </row>

          <row>
            <entry>/</entry>

            <entry>Division</entry>
          </row>

          <row>
            <entry>^</entry>

            <entry>Exponentiation (raise a to the power of b)</entry>
          </row>

          <row>
            <entry>and</entry>

            <entry>logical and (returns 0 or 1)</entry>
          </row>

          <row>
            <entry>or</entry>

            <entry>logical or (returns 0 or 1)</entry>
          </row>

          <row>
            <entry>xor</entry>

            <entry>logical exclusive or (returns 0 or 1)</entry>
          </row>

          <row>
            <entry>&lt;</entry>

            <entry>less then (returns 0 or 1)</entry>
          </row>

          <row>
            <entry>&lt;=</entry>

            <entry>less then or equal (returns 0 or 1)</entry>
          </row>

          <row>
            <entry>==</entry>

            <entry>equal (returns 0 or 1)</entry>
          </row>

          <row>
            <entry>&gt;=</entry>

            <entry>greater then or equal (returns 0 or 1)</entry>
          </row>

          <row>
            <entry>&gt;</entry>

            <entry>greater then (returns 0 or 1)</entry>
          </row>

          <row>
            <entry>!=</entry>

            <entry>not equal (returns 0 or 1)</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

      <table frame="sides" pgwide="1" tocentry="1">
        <title>Mathematical Functions</title>

        <tgroup cols="2">
          <colspec align="left" colname="name" colwidth="1*" />

          <colspec align="justify" colname="description" colwidth="10*" />

          <thead>
            <row>
              <entry>Name</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>abs(x)</entry>

              <entry>absolute value of x</entry>
            </row>

            <row>
              <entry>acos(x)</entry>

              <entry>inverse cosinus</entry>
            </row>

            <row>
              <entry>acosh(x)</entry>

              <entry>inverse hyperbolic cosinus</entry>
            </row>

            <row>
              <entry>asin(x)</entry>

              <entry>inverse sinus</entry>
            </row>

            <row>
              <entry>asinh(x)</entry>

              <entry>inverse hyperbolic sinus</entry>
            </row>

            <row>
              <entry>atan(x)</entry>

              <entry>inverse tangent</entry>
            </row>

            <row>
              <entry>atanh(x)</entry>

              <entry>inverse hyperbolic tangent</entry>
            </row>

            <row>
              <entry>avg(x1,x2,x3,...)</entry>

              <entry>average value, this command accept a list of arguments
              separated by commas</entry>
            </row>

            <row>
              <entry>bessel_j0(x)</entry>

              <entry>Regular cylindrical Bessel function of zeroth order,
              J<subscript>0</subscript>(x).</entry>
            </row>

            <row>
              <entry>bessel_j1(x)</entry>

              <entry>Regular cylindrical Bessel function of first order,
              J<subscript>1</subscript>(x).</entry>
            </row>

            <row>
              <entry>bessel_jn(x,n)</entry>

              <entry>Regular cylindrical Bessel function of
              n<superscript>th</superscript> order,
              J<subscript>n</subscript>(x).</entry>
            </row>

				<row>
					<entry>bessel_jn_zero(n, s)</entry>
					<entry>s<superscript>th</superscript> zero of regular cylindrical Bessel function
						of n<superscript>th</superscript> order,
						J<subscript>n</subscript>(bessel_jn_zero(n,s))=0
					</entry>
				</row>

            <row>
              <entry>bessel_y0(x)</entry>

              <entry>Irregular cylindrical Bessel function of zeroth order,
              Y<subscript>0</subscript>(x) for x&gt;0.</entry>
            </row>

            <row>
              <entry>bessel_y1(x)</entry>

              <entry>Irregular cylindrical Bessel function of first order,
              Y<subscript>1</subscript>(x) for x&gt;0.</entry>
            </row>

            <row>
              <entry>bessel_yn(x,n)</entry>

              <entry>Irregular cylindrical Bessel function of
              n<superscript>th</superscript> order,
              Y<subscript>n</subscript>(x) for x&gt;0.</entry>
            </row>

            <row>
              <entry>beta (a,b)</entry>

              <entry>Computes the Beta Function, B(a,b) =
              Gamma(a)*Gamma(b)/Gamma(a+b) for a &gt; 0 and b &gt; 0.</entry>
            </row>

            <row>
              <entry>ceil(x)</entry>

              <entry>ceiling; smallest integer greater or equal to x</entry>
            </row>

            <row>
              <entry>cos(x)</entry>

              <entry>cosinus of x</entry>
            </row>

            <row>
              <entry>cosh(x)</entry>

              <entry>hyperbolic cosinus of x</entry>
            </row>

            <row>
              <entry>erf(x)</entry>

              <entry>error function of x</entry>
            </row>

            <row>
              <entry>erfc(x)</entry>

              <entry>Complementary error function erfc(x) = 1 -
              erf(x).</entry>
            </row>

            <row>
              <entry>erfz(x)</entry>

              <entry>The Gaussian probability density function Z(x).</entry>
            </row>

            <row>
              <entry>erfq(x)</entry>

              <entry>The upper tail of the Gaussian probability function
              Q(x).</entry>
            </row>

            <row>
              <entry>exp(x)</entry>

              <entry>Exponential function: e raised to the power of x.</entry>
            </row>

            <row>
              <entry>floor(x)</entry>

              <entry>floor; largest integer less than or equal to x</entry>
            </row>

            <row>
              <entry>gamma(x)</entry>

              <entry>Computes the Gamma function, subject to x not being a
              negative integer</entry>
            </row>

            <row>
              <entry>gammaln(x)</entry>

              <entry>Computes the logarithm of the Gamma function, subject to
              x not a being negative integer. For x&lt;0, log(|Gamma(x)|) is
              returned.</entry>
            </row>

            <row>
              <entry>hazard(x)</entry>

              <entry>Computes the hazard function for the normal distribution
              h(x) = erfz(x)/erfq(x).</entry>
            </row>

            <row>
              <entry>ln(x)</entry>

              <entry>natural logarythm of x</entry>
            </row>

            <row>
              <entry>log(x)</entry>

              <entry>decimal logarythm of x</entry>
            </row>

            <row>
              <entry>log2(x)</entry>

              <entry>base 2 logarythm of x</entry>
            </row>

				<row>
					<entry>w0(x)</entry>
					<entry>Principal branch of Lambert's W function, W<subscript>0</subscript>(x).
						W<subscript>0</subscript> is defined as a solution to the equation
						W<subscript>0</subscript>(x)*exp(W<subscript>0</subscript>(x))=x.
						For x&lt;0, there are tow real-valued branches; this function computes the one where
						W&gt;-1 for x&lt;0 (compare w1(x)).
					</entry>
				</row>

				<row>
					<entry>w1(x)</entry>
					<entry>Secondary branch of Lambert's W function, W<subscript>-1</subscript>(x).
						W<subscript>-1</subscript> is defined as a solution to the equation
						W<subscript>-1</subscript>(x)*exp(W<subscript>-1</subscript>(x))=x.
						For x&lt;0, there are tow real-valued branches; this function computes the one where
						W&lt;-1 for x&lt;0 (compare w0(x)).
					</entry>
				</row>

            <row>
              <entry>min(x1,x2,x3,...)</entry>

              <entry>Minimum of the list of arguments</entry>
            </row>

            <row>
              <entry>max(x1,x2,x3,...)</entry>

              <entry>Maximum of the list of arguments</entry>
            </row>

				<row>
					<entry>mod(x,y)</entry>
					<entry>x modulo y; remainder of integer division x/y</entry>
				</row>

				<row>
					<entry>pow(x,y)</entry>
					<entry>x to the power of y, x^y</entry>
				</row>

            <row>
              <entry>rint(x)</entry>

              <entry>Round to nearest integer.</entry>
            </row>

            <row>
              <entry>sign(x)</entry>

              <entry>Sign function: -1 if x&lt;0; 1 if x&gt;0.</entry>
            </row>

            <row>
              <entry>sin(x)</entry>

              <entry>sinus of x</entry>
            </row>

            <row>
              <entry>sinh(x)</entry>

              <entry>hyperblic sinus of x</entry>
            </row>

            <row>
              <entry>sqrt(x)</entry>

              <entry>square root of x</entry>
            </row>

            <row>
              <entry>tan(x)</entry>

              <entry>tangent of x</entry>
            </row>

            <row>
              <entry>tanh(x)</entry>

              <entry>hyperbolic tangent of x</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <table frame="sides" pgwide="1" tocentry="1">
        <title>Non-Mathematical Functions</title>

        <tgroup cols="2">
          <colspec align="left" colname="name" colwidth="1*" />

          <colspec align="justify" colname="description" colwidth="10*" />

          <thead>
            <row>
              <entry>Name</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>cell(a,b)</entry>

				  <entry>In the contex of a matrix, returns the value at row a and column b.
					  In the context of a table, returns the value at column a and row b (remember that tables use column logic).
					  Everywhere else, this function is undefined.

					  In the case of tables, the column is specified as a path string; see the
					  documentation of column() for supported path formats.
				  </entry>
            </row>

				<row>
					<entry>cell_(column, row)</entry>
					<entry>
						In the context of a table, return the value of a cell specified using 1-based indices.
						Wherever possible, you should use cell() instead, because inserting/removing/moving
						columns will break formulas using cell_().
					</entry>
				</row>

            <row>
              <entry>col(c)</entry>

				  <entry>
					  DEPRECATED; use column() or cell() instead.
					  Note that the user interface still uses col() until a proper language-specific mechanism
					  is implemented.
				  </entry>
            </row>

				<row>
					<entry>column("path")</entry>
					<entry>
						In a column formula, returns the value in the given column and current row (i).
						The column path can either be the name of column in the current table, more
						generally a relative path to a column in another table (e.g. "../otherTable/col")
						or an absolute path (i.e., relative to the project root; e.g.
						"/folder/otherTable/col"). Searching for a table anywhere in the project using
						"otherTable/col" (without leading slash) is supported for backwards-compatibility
						reasons, but is strongly discouraged - a future release will drop the requirement
						of project-wide unique table names, at which point this usage will cease to be
						well-defined.
					</entry>
				</row>

				<row>
					<entry>column_(index)</entry>
					<entry>In a column formula, returns the value in the column given by 1-based index
						and current row (i). You should use column() wherever possible, because inserting/
						removing/moving columns will break formulas using column_().
					</entry>
				</row>

            <row>
              <entry>if(e1,e2,e3)</entry>

              <entry>if e1 is true, e2 is executed else e3 is
              executed.</entry>
            </row>

            <row>
              <entry>tablecol(t,c)</entry>

				  <entry>
					  DEPRECATED; use column() instead.
				  </entry>
            </row>
          </tbody>
        </tgroup>
      </table>
  </sect1>

  <sect1 id="sec-python">
    <title>Python</title>
    <indexterm><primary>Scripting</primary><secondary>Python</secondary></indexterm>

    <para>This module provides bindings to the <ulink
    url="http://www.python.org">Python</ulink> programming language. Basic
    usage in the context of &appname; will be discussed below, but for more
    in-depth information on the language itself, please refer to its excellent
    <ulink url="http://www.python.org/doc">documentation</ulink>.</para>

    <sect2>
		 <title>Getting Started</title>

		 <para>Make sure your current project uses Python as its interpreter by
			 selecting the menu point Scripting->Scripting Language and
			 double-clicking on "Python" in the resulting dialog (if the dialog
			 appears, but does not contain the "Python" item, your installation
			 of &appname; has been compiled without Python support).
			 Next, open a Notes window and enter
			 <userinput>print "Hello World!"</userinput>. Position the cursor
			 anywhere on this line and press Ctrl+J, or select "Execute" from
			 the context menu. The string "Hello World!" should appear below the
			 line you entered. Congratulations, you've made contact with Python!
			 You can also enter more complex code fragments, such as function or
			 class definitions, in which case you have to select the whole code
			 block before executing it.</para>

		 <para>You can also use Notes windows as a handy calculator. Enter a
			 mathematical expression on a line of its own - say,
			 <userinput>5*sin(pi/2)</userinput>. Press Ctr+Enter, or select
			 "Evaluate" from the context menu. You are rewarded by a new line,
			 stating (to general astonishment), that the result of evaluating
			 your expression is <computeroutput>#&gt; 5</computeroutput>. If
			 you have <ulink url="http://www.scipy.org">SciPy</ulink> and/or
			 <ulink url="http://pygsl.sf.net">PyGSL</ulink> installed, you
			 will have immediate access to a huge number of interesting
			 functions, browsable via the submenu "Functions" of the context
			 menu. Pressing Shift+F1 while in this menu will give you a short
			 description of the current function. The advantage of only
			 executing/evaluating single lines or selections on request is that
			 you can freely mix text and calculations within a Notes window.</para>

		 <para>Another particularly handy place for using Python code are
			 column formulas. These work just like evaluating expressions
			 in Note windows, with the additional advantage of some pre-defined
			 variables: i (the row currently being computed), j (the column
			 number), sr (start row), er (end row) and self (the table to which the
			 column being computed belongs; see below for what you can do with it).
		 </para>

		 <para>If you are already familiar with Python, you might ask yourself at
			 this point if you can use more complicated column formulas than just
			 single expressions (for instance, if:/else: decisions based on the
			 current row number). The answer is: yes, you can. For the benefit of
			 those not familiar with Python, we will give a short introduction to
			 the language before discussing how to do this.</para>
	 </sect2>

    <sect2>
      <title>Python Basics</title>

		<sect3>
			<title>Expressions</title>

			<para>Mathematical expressions work largely as expected. However,
				there's one caveat, especially when switching from muParser:
				<userinput>a^b</userinput> does not mean "raise a to the power of b" but
				rather "bitwise exclusive or of a and b"; Python's power operator is **.
				Thus: <screen width="40">
<userinput>2^3 # read: 10 xor 11 = 01</userinput>
<computeroutput>#&gt; 1</computeroutput>
<userinput>2**3</userinput>
<computeroutput>#&gt; 8</computeroutput>
			</screen></para>
		</sect3>

		<sect3>
			<title>Statements</title>

			<para>One thing you have to know when working with Python is that
				indentation is very important. It is used for grouping (most other
				languages use either braces or keywords like
				<userinput>do...end</userinput> for this). For example, executing the
				following: <programlisting
					width="40">
x=23
for i in (1,4,5):
	x=i**2
	print(x)
				</programlisting> will do what you would expect: it prints out the numbers 1, 16 and
				25; each on a line of its own. Deleting just a bit of space will change
				the functionality of your program: <programlisting width="40">
x=23
for i in (1,4,5):
	x=i**2
print(x)
			</programlisting> will print out only one number - no, not 23, but rather 25. This
				example was designed to also teach you something about variable scoping:
				There are no block-local variables in Python.</para>

				<para>There are two different variable scopes to be aware of: local and
				global variables. Unless specified otherwise, variables are local to the
				context in which they were defined. Thus, the variable
				<varname>x</varname> can have three different values in, say, two
				different Note windows and a column formula. Global variables on the
				other hand can be accessed from everywhere within your project. A
				variable <varname>x</varname> is declared global by executing the
				statement <userinput>global x</userinput>. You have to do this before
				assigning a value to <varname>x</varname>, but you have to do it only
				once within the project (no need to "import" the variable before using
				it). Note that there is a slight twist to these rules when you
				define your own functions.</para>

				<para>The basic syntax for defining a function (for use within one
				particular note, for example) is <programlisting width="40">
def answer():
	return 42
			</programlisting> If you want your function to be accessible from the rest of your
				project, you have to declare it global before the definition: <programlisting
      width="40">
global answer
def answer():
	return 42
			</programlisting> You can add your own function to &appname;'s function list. We'll
				also provide a documentation string that will show up, for example, in
				the "set column values" dialog: <programlisting width="40">
global answer
def answer():
	"Return the answer to the ultimate question about life, the universe and everything."
	return 42
&python-pref;.mathFunctions["answer"] = answer
			</programlisting> If you want to remove a function from the list,
			execute <programlisting
      width="40">
del &python-pref;.mathFunctions["answer"]
	</programlisting></para>

				<para>Note that functions have their own local scope. That means that if
				you enter a function definition in a Notes window, you will not be able to
				access (neither reading nor writing) Notes-local variables from within
				the function. However, you can access global variables as usual.</para>

				<para>If-then-else decisions are entered as follows: <programlisting width="40">
if x&gt;23:
	print(x)
else:
	print("The value is too small.")
			</programlisting></para>

				<para>You can do loops, too: <programlisting width="40">
		for i in range(1, 11):
			print(i)
			</programlisting> This will print out the numbers between 1 and 10 inclusively (the
				upper limit does not belong to the range, while the lower limit
				does).</para>
		</sect3>
		</sect2>

		<sect2>
			<title>Evaluation Reloaded</title>

			<para>As we've already mentioned above, there's a bit more to evaluation
				than just expressions. Note that Python itself can indeed only
				evaluate expressions; the following describes a feature of &appname;
				added on top of Python in order to support more interesting column
				formulas.</para>

			<para>If you use statements (e.g. variable assignments or control
				structures) in a formula, &appname; will assume it to be the body of a
				function. That is, the following code will not work:
				<programlisting width="40">
a=1
a+a
</programlisting>
				The statement in the first line means that the formula cannot
				be evaluated as a single expression. Instead, the above code assigns
				every row in the column the return value of the following function:
				<programlisting width="40">
def f():
	a=1
	a+a
</programlisting>
				However, since Python does not implicitly interpret expressions as
				something to return, this evaluates to nothing. The correct way
				to enter formulas with statements in them is to explicitly return
				something: <programlisting width="40">
a=1
return a+a
</programlisting></para>

		<para>There is a slight catch associated with this strategy. In a Notes
			window, &appname; will allow you to <emphasis>evaluate</emphasis>
			variable assignments like <userinput>ee=1.6021773e-19</userinput>
			without complaining - but this will not lead to the result presumably
			intended, i.e. introducing a shortcut for the elementary charge to be
			used within the notes window. What actually happens is this: &appname;
			evaluates the function <programlisting width="40">
def f():
	ee=1.6021773e-19
</programlisting>
			As mentioned in the Python introduction above, the function f has its
			own variable scope and (unless it happens to be declared global) the
			variable ee will only be visible within this scope (instead of the
			Notes window's scope). The solution is simple: always
			<emphasis>execute</emphasis> things like assignments and function
			definitions, never <emphasis>evaluate</emphasis> them.</para>
	 </sect2>

    <sect2 id="Python-functions">
      <title>Mathematical Functions</title>
    <indexterm><primary>Scripting</primary><secondary>Python</secondary><tertiary>Mathematical functions</tertiary></indexterm>

      <para>Python comes with some basic mathematical functions that are
      automatically imported (if you use the <link
      linkend="Python-init">initialization file</link> shipped with &appname;).
      Along with them, the constants e (Euler's number) and pi (the one and
      only) are defined. Many, many more functions can be obtained by installing
		<ulink url="http://www.scipy.org">SciPy</ulink> and/or
		<ulink url="http://pygsl.sf.net">PyGSL</ulink>.</para>

      <table frame="sides" pgwide="1" tocentry="1">
        <title>Supported Mathematical Functions</title>

        <tgroup cols="2">
          <colspec align="left" colname="name" colwidth="1*" />

          <colspec align="justify" colname="description" colwidth="10*" />

          <thead>
            <row>
              <entry>Name</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>acos(x)</entry>

              <entry>inverse cosinus</entry>
            </row>

            <row>
              <entry>asin(x)</entry>

              <entry>inverse sinus</entry>
            </row>

            <row>
              <entry>atan(x)</entry>

              <entry>inverse tangent</entry>
            </row>

            <row>
              <entry>atan2(y,x)</entry>

              <entry>equivalent to atan(y/x), but more efficient</entry>
            </row>

            <row>
              <entry>ceil(x)</entry>

              <entry>ceiling; smallest integer greater or equal to x</entry>
            </row>

            <row>
              <entry>cos(x)</entry>

              <entry>cosinus of x</entry>
            </row>

            <row>
              <entry>cosh(x)</entry>

              <entry>hyperbolic cosinus of x</entry>
            </row>

            <row>
              <entry>degrees(x)</entry>

              <entry>convert angle from radians to degrees</entry>
            </row>

            <row>
              <entry>exp(x)</entry>

              <entry>Exponential function: e raised to the power of x.</entry>
            </row>

            <row>
              <entry>fabs(x)</entry>

              <entry>absolute value of x</entry>
            </row>

            <row>
              <entry>floor(x)</entry>

              <entry>largest integer smaller or equal to x</entry>
            </row>

            <row>
              <entry>fmod(x,y)</entry>

              <entry>remainder of integer division x/y</entry>
            </row>

            <row>
              <entry>frexp(x)</entry>

              <entry>Returns the tuple (mantissa,exponent) such that
              x=mantissa*(2**exponent) where exponent is an integer and 0.5
              &lt;=abs(m)&lt;1.0</entry>
            </row>

            <row>
              <entry>hypot(x,y)</entry>

              <entry>equivalent to sqrt(x*x+y*y)</entry>
            </row>

            <row>
              <entry>ldexp(x,y)</entry>

              <entry>equivalent to x*(2**y)</entry>
            </row>

            <row>
              <entry>log(x)</entry>

              <entry>natural (base e) logarythm of x</entry>
            </row>

            <row>
              <entry>log10(x)</entry>

              <entry>decimal (base 10) logarythm of x</entry>
            </row>

            <row>
              <entry>modf(x)</entry>

              <entry>return fractional and integer part of x as a
              tuple</entry>
            </row>

            <row>
              <entry>pow(x,y)</entry>

              <entry>x to the power of y; equivalent to x**y</entry>
            </row>

            <row>
              <entry>radians(x)</entry>

              <entry>convert angle from degrees to radians</entry>
            </row>

            <row>
              <entry>sin(x)</entry>

              <entry>sinus of x</entry>
            </row>

            <row>
              <entry>sinh(x)</entry>

              <entry>hyperblic sinus of x</entry>
            </row>

            <row>
              <entry>sqrt(x)</entry>

              <entry>square root of x</entry>
            </row>

            <row>
              <entry>tan(x)</entry>

              <entry>tangent of x</entry>
            </row>

            <row>
              <entry>tanh(x)</entry>

              <entry>hyperbolic tangent of x</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </sect2>

    <sect2 id="Python-API-Intro">
      <title>Accessing &appname;'s functions from Python</title>

      <para>We will assume that you are using the <link
      linkend="Python-init">initialization file</link> shipped with
      &appname;.</para>

      <sect3>
        <title>Establishing contact</title>

        <para>Accessing the objects in your project is straight-forward,
        <programlisting width="40">
t = table("Table1")
m = matrix("Matrix1")
g = graph("Graph1")
n = note("Notes1")
	  </programlisting> as is creating new objects: <programlisting width="40">
# create an empty table named "tony" with 5 rows and 2 columns:
t = newTable("tony", 5, 2)
# use defaults
t = newTable()
# create an empty matrix named "gina" with 42 rows and 23 columns:
m = newMatrix("gina", 42, 23)
# use defaults
m = newMatrix()
# create an empty graph window
g = newGraph()
# create an empty note named "momo"
n = newNote("momo")
# use defaults
n = newNote()
	  </programlisting></para>
	  <para>
	    New objects will always be added to the active folder.
	    The functions table, matrix, graph and note will start searching in the active folder and, failing this, continue with a depth-first recursive search of the project's root folder.
	    In order to access other folders, there are the functions
	    <programlisting width="40">
f = activeFolder()
# and
f = rootFolder()
</programlisting>
	    which can be used to access subfolders and windows:
	    <programlisting width="40">
f2 = f.folders()[number]
f2 = f.folder(name, caseSensitive=True, partialMatch=False)
t = f.table(name, recursive=False)
m = f.matrix(name, recursive=False)
g = f.graph(name, recursive=False)
n = f.note(name, recursive=False)
</programlisting>
            If you supply True for the recursive argument, a depth-first recursive search of all subfolders will be performed and the first match returned.</para>


        <para>Also, every piece of code is executed in the context of an
	  object which you can access via the <varname>self</varname> variable. For example,
        entering <userinput>self.cell("t",i)</userinput> as a column formula
        is equivalent to the convenience function
        <userinput>col("t")</userinput>.</para>
      </sect3>

      <sect3>
        <title>Working with Tables</title>

        <para>We'll assume that you have assigned some table to the variable
        <varname>t</varname>. You can access its numeric cell values with
        <programlisting width="40">
t.cell(col, row)
# and
t.setCell(col, row, value)
	  </programlisting> Whenever you have to specify a column, you can use either the
        column name (as a string) or the consecutive column number (starting
        with 1). Row numbers also start with 1, just as they are displayed. If
        you want to work with arbitrary texts or the textual representations
        of numeric values, you can use <programlisting width="40">
t.text(col, row)
# and
t.setText(col, row, string)
	  </programlisting> The number of columns and rows is accessed via <programlisting
        width="40">
t.numRows()
t.numCols()
t.setNumRows(number)
t.setNumCols(number)
	  </programlisting> Column names can be read and written with <programlisting width="40">
t.colName(number)
t.setColName(col, newName)
	  </programlisting> Normalize a single or all columns: <programlisting width="40">
t.normalize(col)
t.normalize()
	  </programlisting> Import values from <varname>file</varname>, using
        <varname>sep</varname> as separator char and ignoring
        <varname>ignore</varname> lines at the head of the file. The flags
        should be self-explanatory. <programlisting width="40">
t.importASCII(file, sep="\t", ignore=0, renameCols=False, stripSpaces=True, simplifySpace=False, newTable=False)
	  </programlisting> After having changed some table values from a script, you will
        likely want to update dependent Graphs: <programlisting width="40">
t.notifyChanges()
	  </programlisting></para>

        <para>As a simple example, let's set some column values without using
        the dialog. <programlisting width="40">
t = table("table1")
for i in range(1, t.numRows()+1):
	t.setCell(1, i, i**2)
t.notifyChanges()
	  </programlisting></para>
      </sect3>

      <sect3>
        <title>Working with Matrices</title>

        <para>We'll assume that you have assigned some matrix to the variable
        <varname>m</varname>. Accessing cell values is very similar to Table,
        but since Matrix doesn't use column logic, row arguments are specified
        before columns and obviously you can't use column name. <programlisting
        width="40">
m.cell(row, col)
m.setCell(row, col, value)
m.text(row, col)
m.setText(row, col, string)
	  </programlisting> Also like with tables, there's <programlisting width="40">
m.numRows()
# and
m.numCols()
	  </programlisting></para>
      </sect3>

      <sect3>
        <title>Plotting and Working with Graphs</title>

        <para>If you want to create a new Graph window for some data in table
        table1, you can use the plot command: <programlisting width="40">
g = plot(table, column, type)
	  </programlisting> <varname>type</varname> is a number between 0 and 10 and
        specifies the desired plot type: <variablelist spacing="compact">
            <varlistentry>
              <term>0.</term>

              <listitem>
                <para>Line</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>1.</term>

              <listitem>
                <para>Symbols</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>2.</term>

              <listitem>
                <para>Line and Symbols</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>3.</term>

              <listitem>
                <para>Columns</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>4.</term>

              <listitem>
                <para>Area</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>5.</term>

              <listitem>
                <para>Pie</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>6.</term>

              <listitem>
                <para>Vertical drop lines</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>7.</term>

              <listitem>
                <para>Splines and Symbols</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>8.</term>

              <listitem>
                <para>Vertical steps</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>9.</term>

              <listitem>
                <para>Histogram</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>10.</term>

              <listitem>
                <para>Rows</para>
              </listitem>
            </varlistentry>
          </variablelist> You can plot more than one column at once by giving
        a Python tuple (see the <ulink url="http://docs.python.org/tut">Python
        Tutorial</ulink>) as an argument: <programlisting width="40">
g = plot(table("table1"), (2,4,7), 2)
	  </programlisting></para>

        <para>If you want to add a curve to an existing Graph window, you have
        to choose the destination layer. Usually, <programlisting width="40">
l = g.activeLayer()
	  </programlisting> will do the trick, but you can also select a layer by its number:
        <programlisting width="40">
l = g.layer(num)
	  </programlisting> You can then add or remove curves to or from this layer: <programlisting
        width="40">
l.insertCurve(table, column, type=1)
l.insertCurve(table, Xcolumn, Ycolumn, type=1)
l.removeCurve(curveName)
l.removeCurve(curveNumber)
l.deleteFitCurves()
	  </programlisting> In case you need the number of curves on a layer, you can get it
        with <programlisting width="40">
l.numCurves()
	  </programlisting></para>

        <para>Layers and whole Graphs can be printed and exported from within
        Python. Before you do this, you would probably want to change layer and axis
        titles as well as legend texts: <programlisting width="40">
l.setTitle(title)
l.setXTitle(Xtitle)
l.setYTitle(Ytitle)
l.setLegend(text)
	  </programlisting> You can also customize the scales of the different axes using: <programlisting width="40">
l.setScale(int axis, double start, double end, double step=0.0, int majorTicks=5, int minorTicks=5, int type=0, bool inverted=False);
</programlisting>
	  where <varname>axis</varname> is a number between 0 and 3 with the following signification: <variablelist spacing="compact">
            <varlistentry>
              <term>0.</term>

              <listitem>
                <para>Left axis</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>1.</term>

              <listitem>
                <para>Right axis</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>2.</term>

              <listitem>
                <para>Bottom axis</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>3.</term>

              <listitem>
                <para>Top axis</para>
              </listitem>
            </varlistentry>
          </variablelist>
<varname>type</varname> specifies the desired scale type: <variablelist spacing="compact">
            <varlistentry>
              <term>0.</term>

              <listitem>
                <para>Linear</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>1.</term>

              <listitem>
                <para>Log10</para>
              </listitem>
            </varlistentry>
          </variablelist>
	  and <varname>step</varname> defines the size of the interval between the major scale ticks. If not specified (default value is 0.0), the step size is calculated automatically.
	  The other flags should be self-explanatory.
	  Now, here is how you can export a layer <programlisting width="40">
l.print()
l.exportToSVG(filename)
l.exportToEPS(filename)
l.exportImage(filename, filetype="PNG", quality=100, transparent=False)
	  </programlisting> and a graph <programlisting width="40">
g.print()
g.exportToSVG(filename)
g.exportToEPS(filename)
	  </programlisting></para>
      </sect3>

      <sect3>
        <title>Fitting</title>

        <para>Assuming you have a Graph named "graph1" with a curve entitled
        "table1_2" (on its active layer), a minimal Fit example would be:
        <programlisting width="40">
f = GaussFit(graph("graph1").activeLayer(), "table1_2")
f.guessInitialValues()
f.fit()
	  </programlisting> This creates a new GaussFit object on the curve, lets it guess
        the start parameters and does the fit. The following fit types are
        supported: <itemizedlist>
            <listitem>
              <para>LinearFit(layer, curve)</para>
            </listitem>

            <listitem>
              <para>PolynomialFit(layer, curve, degree=2, legend=False)</para>
            </listitem>

            <listitem>
              <para>ExponentialFit(layer, curve, growth=False)</para>
            </listitem>

            <listitem>
              <para>TwoExpFit(layer, curve)</para>
            </listitem>

            <listitem>
              <para>ThreeExpFit(layer, curve)</para>
            </listitem>

            <listitem>
              <para>GaussFit(layer, curve)</para>
            </listitem>

            <listitem>
              <para>GaussAmpFit(layer, curve)</para>
            </listitem>

            <listitem>
              <para>LorentzFit(layer,curve)</para>
            </listitem>

            <listitem>
              <para>SigmoidalFit(layer, curve)</para>
            </listitem>

            <listitem>
              <para>NonLinearFit(layer, curve)</para>
		    <programlisting width="40">
f = NonLinearFit(layer, curve)
f.setParameters(name1, ...)
f.setFormula(formula_string)
		    </programlisting>
            </listitem>

            <listitem>
		    <para>PluginFit(layer, curve)</para>
		    <programlisting width="40">
f = PluginFit(layer, curve)
f.load(pluginName)
		    </programlisting>
            </listitem>
          </itemizedlist> For each of these, you can optionally restrict the X
        range that will be used for the fit, like in <programlisting width="40">
f = LinearFit(graph("graph1").activeLayer(), "table1_2", 2, 7)
f.fit()
	  </programlisting></para>

        <para>After creating the Fit object and before calling its fit()
        method, you can set a number of parameters that influence the fit:
        <programlisting width="80">
f.setDataFromCurve(curve)			<lineannotation>change data source</lineannotation>
f.setDataFromCurve(curve, graph)		<lineannotation>change data source</lineannotation>
f.setDataFromCurve(curve, from, to)		<lineannotation>change data source</lineannotation>
f.setDataFromCurve(curve, from, to, graph)	<lineannotation>change data source</lineannotation>
f.setInterval(from, to)				<lineannotation>change data range</lineannotation>
f.setInitialValue(number, value)
f.setInitialValues(value1, ...)
f.guessInitialValues()
f.setAlgorithm(algo) # algo = Fit.ScaledLevenbergMarquardt, Fit.UnscaledLevenbergMarquardt, Fit.NelderMeadSimplex
f.setWeightingData(method, colname) # method = Fit.NoWeighting, Fit.Instrumental, Fit.Statistical, Fit.Dataset
f.setTolerance(tolerance)
f.setOutputPrecision(precision)
f.setMaximumIterations(number)
f.scaleErrors(yes = True)
f.setColor(qt.QColor("green"))			<lineannotation>change the color of the result fit curve to green (default color is red)</lineannotation>
	  </programlisting></para>

        <para>After you've called fit(), you have a number of possibilities
        for extracting the results: <programlisting width="40">
f.results()
f.errors()
f.chiSquare()
f.rSquare()
f.dataSize()
f.numParameters()
f.parametersTable("params")
f.covarianceMatrix("cov")
	  </programlisting></para>
      </sect3>
    </sect2>

	 <sect2 id="Python-API">
		 <title>API documentation</title>
		 <para>Classes mentioned below that start with "Q" belong to Qt and can be used via PyQt.
			 If you want to know what you can do with such classes (e.g. QIcon or QDateTime), see the
			 <ulink url="http://www.riverbankcomputing.co.uk/static/Docs/PyQt4/html/classes.html">PyQt
				 reference documentation</ulink>.
		 </para>
		 <sect3><title>class AbstractAspect (inherits QObject)</title>
			 <para>A base class for content of a project. While currently the only AbstractAspect
				 accessible to you is Column, a future release will make more extensive usage of this;
				 probably with some revisions in the design, so only some basic functions are documented
				 (and supported) for now.</para>
			 <variablelist spacing="compact">
				 <varlistentry>
					 <term>index()</term>
					 <listitem>Return the 0-based index of the Aspect in its sibling list.</listitem>
				 </varlistentry>
				 <varlistentry>
					 <term>name()</term>
					 <listitem>Return the Aspect's name.</listitem>
				 </varlistentry>
				 <varlistentry>
					 <term>setName(string)</term>
					 <listitem>Change the Aspect's name.</listitem>
				 </varlistentry>
				 <varlistentry>
					 <term>comment()</term>
					 <listitem>Return comment attached to the Aspect.</listitem>
				 </varlistentry>
				 <varlistentry>
					 <term>setComment(string)</term>
					 <listitem>Change the comment attached to the Aspect.</listitem>
				 </varlistentry>
				 <varlistentry>
					 <term>icon()</term>
					 <listitem>Return the icon (a QIcon) used to designate the Aspect's type; for columns,
						 this is the data type icon in the table header.</listitem>
				 </varlistentry>
				 <varlistentry>
					 <term>creationTime()</term>
					 <listitem>Return point in time the Aspect was created by the user (as a QDateTime).</listitem>
				 </varlistentry>
				 <varlistentry>
					 <term>remove()</term>
					 <listitem>Remove Aspect from the project (can be undone using Edit-&gt;Undo menu).</listitem>
				 </varlistentry>
				 <varlistentry>
					 <term>signal void aspectDescriptionAboutToChange(const AbstractAspect*)</term>
					 <listitem>Emitted before the description (name or comment) is changed.</listitem>
				 </varlistentry>
				 <varlistentry>
					 <term>signal void aspectDescriptionChanged(const AbstractAspect*)</term>
					 <listitem>Emitted after the description (name or comment) has changed.</listitem>
				 </varlistentry>
				 <varlistentry>
					 <term>signal void aspectAboutToBeRemoved(const AbstractAspect*)</term>
					 <listitem>Emitted before the Aspect is removed.</listitem>
				 </varlistentry>
			 </variablelist>
		 </sect3>
		 <sect3><title>class Column (inherits AbstractAspect)</title>
			 <para>Represents a column in a table.</para>
			 <variablelist spacing="compact">
				 <varlistentry>
					 <term>columnMode()</term>
					 <listitem>A string designating the data type; one of "Numeric", "Text", "Month",
						 "Day" or "DateTime".</listitem>
				 </varlistentry>
				 <varlistentry>
					 <term>setColumnMode(string)</term>
					 <listitem>Change the column's data type; argument must be one of "Numeric", "Text",
						 "Month", "Day" or "DateTime".</listitem>
				 </varlistentry>
				 <varlistentry>
					 <term>copy(Column)</term>
					 <listitem>Copy complete content of other column, which must have the same data type (mode).
					 Returns a boolean indicating success or failure.</listitem>
				 </varlistentry>
				 <varlistentry>
					 <term>copy(Column,int,int,int)</term>
					 <listitem>copy(source, source_start, dest_start, num_rows) copies num_rows values from source,
						 starting to read at row source_start and to write at row dest_start.</listitem>
				 </varlistentry>
				 <varlistentry>
					 <term>rowCount()</term>
					 <listitem>Number of rows in the column.</listitem>
				 </varlistentry>
				 <varlistentry>
					 <term>insertRows(int, int)</term>
					 <listitem>insertRows(before, count) insert count empty rows before row numbered before</listitem>
				 </varlistentry>
				 <varlistentry>
					 <term>removeRows(int, int)</term>
					 <listitem>removeRows(first, count) removes count rows starting with row numbered first</listitem>
				 </varlistentry>
				 <varlistentry>
					 <term>plotDesignation()</term>
					 <listitem>Return a string representing the plot designation of the column; one of "noDesignation", "X", "Y", "Z", "xErr" or "yErr".</listitem>
				 </varlistentry>
				 <varlistentry>
					 <term>setPlotDesignation(string)</term>
					 <listitem>Set the plot designation. The argument must be one of "noDesignation", "X", "Y", "Z", "xErr" or "yErr".</listitem>
				 </varlistentry>
				 <varlistentry>
					 <term>clear()</term>
					 <listitem>Clear content of all cells in the column, marking them as empty/invalid.</listitem>
				 </varlistentry>
				 <varlistentry>
					 <term>isInvalid(int)</term>
					 <listitem>Returns boolean indicating whether the given row is marke as empty/invalid.</listitem>
				 </varlistentry>
				 <varlistentry>
					 <term>formula(int)</term>
					 <listentry>Return formula used to compute the cell value in the given row.</listentry>
				 </varlistentry>
				 <varlistentry>
					 <term>setFormula(int, string)</term>
					 <listentry>Sets formula for the given row to string.</listentry>
				 </varlistentry>
				 <varlistentry>
					 <term>clearFormulas()</term>
					 <listentry>Discard all formulas associated with cells.</listentry>
				 </varlistentry>
				 <varlistentry>
					 <term>valueAt(int)</term>
					 <listentry>Retrieve value of the specified cell, assuming that the column has columnMode() == "Numeric".</listentry>
				 </varlistentry>
				 <varlistentry>
					 <term>setValueAt(int, double)</term>
					 <listentry>Set value of specified cell, assuming that the column has columnMode() == "Numeric".</listentry>
				 </varlistentry>
				 <varlistentry>
					 <term>replaceValues(int, list of double values)</term>
					 <listentry>Mass-update cells starting at the indicated row, assuming that the column's columnMode() is one of "Numeric". Compared with setValueAt(), this has the advantage of being much more efficient; particularly if the column has dependant plots.</listentry>
				 </varlistentry>
				 <varlistentry>
					 <term>textAt(int)</term>
					 <listentry>Retrieve value of the specified cell, assuming that the column has columnMode() == "Text".</listentry>
				 </varlistentry>
				 <varlistentry>
					 <term>setTextAt(int, string)</term>
					 <listentry>Set value of specified cell, assuming that the column has columnMode() == "Text".</listentry>
				 </varlistentry>
				 <varlistentry>
					 <term>replaceTexts(int, list of strings)</term>
					 <listentry>Mass-update cells starting at the indicated row, assuming that the column has columnMode() == "Text". Compared with setTextAt(), this has the advantage of being much more efficient; particularly if the column has dependant plots.</listentry>
				 </varlistentry>
				 <varlistentry>
					 <term>dateAt(int)</term>
					 <listentry>Retrieve value of the specified cell, assuming that the column's columnMode() is one of "Month", "Day", "DateTime".</listentry>
				 </varlistentry>
				 <varlistentry>
					 <term>setDateAt(int, QDate)</term>
					 <listentry>Set value of specified cell, assuming that the column's columnMode() is one of "Month", "Day", "DateTime".</listentry>
				 </varlistentry>
				 <varlistentry>
					 <term>timeAt(int)</term>
					 <listentry>Retrieve value of the specified cell, assuming that the column has columnMode() == "DateTime".</listentry>
				 </varlistentry>
				 <varlistentry>
					 <term>setTimeAt(int, QTime)</term>
					 <listentry>Set value of specified cell, assuming that the column has columnMode() == "DateTime".</listentry>
				 </varlistentry>
				 <varlistentry>
					 <term>dateTimeAt(int)</term>
					 <listentry>Retrieve value of the specified cell, assuming that the column's columnMode() is one of "Month", "Day", "DateTime".</listentry>
				 </varlistentry>
				 <varlistentry>
					 <term>setDateTimeAt(int, QDateTime)</term>
					 <listentry>Set value of specified cell, assuming that the column's columnMode() is one of "Month", "Day", "DateTime".</listentry>
				 </varlistentry>
				 <varlistentry>
					 <term>replaceDateTimes(int, list of QDateTime values)</term>
					 <listentry>Mass-update cells starting at the indicated row, assuming that the column's columnMode() is one of "Month", "Day", "DateTime". Compared with setDateTimeAt(), this has the advantage of being much more efficient; particularly if the column has dependant plots.</listentry>
				 </varlistentry>
			 </variablelist>
		 </sect3>
		 <sect3><title>class MDIWindow (inherits QWidget)</title>
			 <para>Base class of Table, Matrix, Graph and Note. A redesigned analogue under the name of "Part" (inheriting from AbstractAspect) is under development; it should be possible to provide a backwards-compatible interface, though.</para>
			 <variablelist spacing="compact">
				 <varlistentry>
					 <term>name()</term>
					 <listentry>Return the window's name (added in &appname; 0.2.3).</listentry>
				 </varlistentry>
				 <varlistentry>
					 <term>setName(string)</term>
					 <listentry>Set window's name. IMPORTANT: This was added in &appname; 0.2.3, but unfortunately is BROKEN in this release. Usable starting with &appname; 0.2.4.</listentry>
				 </varlistentry>
				 <varlistentry>
					 <term>windowLabel()</term>
					 <listentry>Returns the comment associated with the window (yes, the confusing name will be fixed in a future release).</listentry>
				 </varlistentry>
				 <varlistentry>
					 <term>setWindowLabel(string)</term>
					 <listentry>Set comment associated with the window (yes, the confusing name will be fixed in a future release).</listentry>
				 </varlistentry>
				 <varlistentry>
					 <term>captionPolicy()</term>
					 <listentry>Return caption policy (i.e., what to display in the title bar). One of the integer constants MDIWindow.Name, MDIWindow.Label or MDIWindow.Both.</listentry>
				 </varlistentry>
				 <varlistentry>
					 <term>setCaptionPolicy(int)</term>
					 <listentry>Set caption policy (i.e., what to display in the title bar). Must be one of the integer constants MDIWindow.Name, MDIWindow.Label or MDIWindow.Both.</listentry>
				 </varlistentry>
				 <varlistentry>
					 <term>folder()</term>
					 <listentry>Return the folder this window belongs to (an object of class Folder).</listentry>
				 </varlistentry>
				 <varlistentry>
					 <term>confirmClose(boolean)</term>
					 <listentry>Set a flag indicating whether the user should be given the opportunity to cancel removing the window or minimize it instead when trying to close it. When False, close() will remove the window without asking for confirmation, which is useful for temporary objects created by a script.</listentry>
				 </varlistentry>
			 </variablelist>
		 </sect3>
		 <sect3><title>class Table (inherits MDIWindow)</title>
			 <para>Class of table (spreadsheet) windows.</para>
			 <variablelist spacing="compact">
				 <varlistentry>
					 <term>numRows()</term>
					 <listentry>Returns the number of rows of the table.</listentry>
				 </varlistentry>
				 <varlistentry>
					 <term>numCols()</term>
					 <listentry>Returns the number of columns of the table.</listentry>
				 </varlistentry>
				 <varlistentry>
					 <term>setNumRows(int)</term>
					 <listentry>Sets the number of rows of the table.</listentry>
				 </varlistentry>
				 <varlistentry>
					 <term>setNumCols(int)</term>
					 <listentry>Sets the number of columns of the table.</listentry>
				 </varlistentry>
				 <varlistentry>
					 <term>column(string or int)</term>
					 <listentry>Returns Column indicated by name (preferred) or 0-based index. For the latter form, keep in mind that inserting, removing or moving columns will break scripts which refer to a specific column by index.</listentry>
				 </varlistentry>
				 <varlistentry>
					 <term>text(string or int, int)</term>
					 <listentry>DEPRECATED. Use column(col).textAt(row) or str(column(col).valueAt(row)) instead (depending on the column's mode).</listentry>
				 </varlistentry>
				 <varlistentry>
					 <term>cell(string or int, int)</term>
					 <listentry>DEPRECATED. Use column(col).valueAt(row) instead.</listentry>
				 </varlistentry>
				 <varlistentry>
					 <term>setText(string or int, int, string</term>
					 <listentry>DEPRECATED. Use column(col).setTextAt(row,value) instead.</listentry>
				 </varlistentry>
				 <varlistentry>
					 <item>setCell(string or int, int, double</term>
					 <listentry>DEPRECATED. Use column(col).setValueAt(row,value) instead.</listentry>
				 </varlistentry>
				 <varlistentry>
					 <item>colName(int)</item>
					 <listentry>DEPRECATED. Use column(col).name() instead.</listentry>
				 </varlistentry>
				 <varlistentry>
					 <item>setColName(int,string)</item>
					 <listentry>DEPRECATED. Use column(col).setName(name) instead.</listentry>
				 </varlistentry>
				 <varlistentry>
					 <item>setComment(int,string)</item>
					 <listentry>DEPRECATED. Use column(col).setComment(text) instead.</listentry>
				 </varlistentry>
				 <varlistentry>
					 <item>setCommand(string or int, string)</item>
					 <listentry>Set formula indicated by first argument to the text given in the second argument.</listentry>
				 </varlistentry>
				 <varlistentry>
					 <item>notifyChanges()</item>
					 <listentry>DEPRECATED. Update notifications are now done automatically.</listentry>
				 </varlistentry>
				 <varlistentry>
					 <item>importASCII(string, string, int, bool, bool, bool)</item>
					 <listentry>importASCII(file, separator=&quot;\t&quot;, ignored_lines=0, rename_cols=False, strip_spaces=True, simplify_spaces=False)
						 imports file into this table, skipping ignored_lines lines at the beginning and
						 splitting the rest into columns according to the given separator and flags.</listentry>
				 </varlistentry>
				 <varlistentry>
					 <item>exportASCII(string, string, bool, bool)</item>
					 <listentry>exportASCII(file, separator=&quot;\t&quot;, with_comments=False, selection_only=False)
						 exports this table to the given file with the column separator given in the second argument;
						 optionally including column comments and optionally exporting only selected cells.</listentry>
				 </varlistentry>
				 <varlistentry>
					 <item>normalize(string or int)</item>
					 <listentry>Normalize specified column to a maximum cell value of one.</listentry>
				 </varlistentry>
				 <varlistentry>
					 <item>normalize()</item>
					 <listentry>Normalize table to a maximum cell value of one.</listentry>
				 </varlistentry>
				 <varlistentry>
					 <item>sortColumn(string or int, int=0)</item>
					 <listentry>Sort column indicated in the first argument. The second argument selects
						 the sorting order; 0 means ascending, 1 means descending.</listentry>
				 </varlistentry>
				 <varlistentry>
					 <item>sort(int=0, int=0, string="")</item>
					 <listentry>sort(type, order, leading_column) sorts all columns in the table either separately
						 (type=0) or together (type=1) with the leading column given by name. The second argument selects
						 the sorting order; 0 means ascending, 1 means descending.</listentry>
				 </varlistentry>
				 <varlistentry>
					 <item>sortColumns(list of strings, int, int, string)</item>
					 <listentry>sortColumns(columns, type=0, order=0, leading_column="") sorts columns given as a tuple of
						 names either separately (type=0) or together (type=1) with the leading column given by name.
						 The third argument selects the sorting order; 0 means ascending, 1 means descending.</listentry>
				 </varlistentry>
			 </variablelist>
		 </sect3>
		 <sect3><title>class Matrix (inherits MDIWindow)</title>
			 <para>Class of matrix windows.</para>
			 <variablelist spacing="compact">
				 <varlistentry>
					 <item>numRows()</item>
					 <listentry>Returns the number of rows in the matrix.</listentry>
				 </varlistentry>
				 <varlistentry>
					 <item>numCols()</item>
					 <listentry>Returns the number of columns in the matrix.</listentry>
				 </varlistentry>
				 <varlistentry>
					 <item>setNumRows(int)</item>
					 <listentry>Changes the number of rows in the matrix.</listentry>
				 </varlistentry>
				 <varlistentry>
					 <item>setNumCols(int)</item>
					 <listentry>Changes the number of columns in the matrix.</listentry>
				 </varlistentry>
				 <varlistentry>
					 <item>setDimensions(int,int)</item>
					 <listentry>setDimensions(rows, cols) changes the number of rows and columns simultaneously.</listentry>
				 </varlistentry>
				 <varlistentry>
					 <item>cell(int,int)</item>
					 <listentry>cell(row,column) returns the content of the indicated cell as a number.</listentry>
				 </varlistentry>
				 <varlistentry>
					 <item>text(int,int)</item>
					 <listentry>text(row,column) returns the content of the indicated cell as its textual representation.</listentry>
				 </varlistentry>
				 <varlistentry>
					 <item>setCell(int,int,double)</item>
					 <listentry>setCell(row,column,value) changes the content of the indicated cell to the indicated numeric value.</listentry>
				 </varlistentry>
				 <varlistentry>
					 <item>setText(int,int,string)</item>
					 <listentry>setText(row,column,value) interprets the string value according to the numeric format of the matrix
						 and changes the content of the indicated cell accordingly.</listentry>
				 </varlistentry>
				 <varlistentry>
					 <item>xStart()</item>
					 <listentry>Returns logical X coordinate of the first column.</listentry>
				 </varlistentry>
				 <varlistentry>
					 <item>xEnd()</item>
					 <listentry>Returns logical X coordinate of the last column.</listentry>
				 </varlistentry>
				 <varlistentry>
					 <item>yStart()</item>
					 <listentry>Returns logical Y coordinate of the first row.</listentry>
				 </varlistentry>
				 <varlistentry>
					 <item>yEnd()</item>
					 <listentry>Returns logical Y coordinate of the last row.</listentry>
				 </varlistentry>
				 <varlistentry>
					 <item>setCoordinates(double,double,double,double)</item>
					 <listentry>setCoordinates(x_start, x_end, y_start, y_end) changes the logical
						 coordinate system associated with the matrix.</listentry>
				 </varlistentry>
				 <varlistentry>
					 <item>setFormula(string)</item>
					 <listentry>Changes the formula used to (re)calculate cell values of the matrix.</listentry>
				 </varlistentry>
				 <varlistentry>
					 <item>setNumericPrecision(int)</item>
					 <listentry>Changes the number of decimal digits being displayed.</listentry>
				 </varlistentry>
				 <varlistentry>
					 <item>transpose()</item>
					 <listentry>Mirror matrix at main diagonal (aka matrix transposition).</listentry>
				 </varlistentry>
				 <varlistentry>
					 <item>invert()</item>
					 <listentry>Replace the content of the matrix by its inverse (with respect to matrix multiplication).</listentry>
				 </varlistentry>
				 <varlistenty>
					 <item>determinant()</item>
					 <listentry>Returns determinant of the matrix.</listentry>
				 </varlistentry>
			 </variablelist>
	 </sect2>

    <sect2 id="Python-init">
      <title>The Initialization File</title>

      <para>This file allows you to customize the Python environment, import
      modules and define functions and classes that will be available in all
      of your projects. The default initialization file shipped with &appname;
      imports Python's <link linkend="Python-functions">standard math
      functions</link> as well as special functions from <ulink
		url="http://www.scipy.org">SciPy</ulink> and <ulink
		url="http://pygsl.sf.net">PyGSL</ulink>(if available). Also, it
      creates some handy shortcuts, like
      <userinput>table("table1")</userinput> for
      <userinput>&python-pref;.app.table("table1")</userinput>.</para>

      <para>When activating Python support, &appname; searches the following
      places, executing the first file it can find:</para>

      <orderedlist>
        <listitem>
          <para>~/.&python-rc;[c]</para>
        </listitem>

        <listitem>
          <para>/etc/&python-rc;[c]</para>
        </listitem>

        <listitem>
          <para>./&python-rc;[c]</para>
        </listitem>
      </orderedlist>

      <para>Files ending in .pyc are compiled versions of the .py source files
      and therefore load a bit faster. The compiled version will be used if
      the source file is older or nonexistent. Otherwise, &appname; will try to
      compile the source file (if you've got write permissions for the output
      file).</para>

		<sect3>
			<title>Recommended approach to per-user configuration</title>

			<para>
				In order to give you full controll over the process of setting up the
				Python environment within &appname;, a per-user configuration file
				(.&python-rc;) will supersede any system-wide configuration file. That
				is, GSL and SciPy functions as well as many &appname;-specific
				functions (like table(), newTable(), plot(), etc.) will be missing,
				unless you explicitly import them into the global namespace. In order
				to keep the overview over their customizations and profit from updates
				to the global configuration files (e.g. with new versions of
				&appname;), most users will want to import the global configuration
				file from within their custom one. Here's how to do this:
			</para>

			<programlisting width="40">
import sys 
sys.path.append("/etc") 
import scidavisrc 
# your custom stuff
</programlisting>
		</sect3>
    </sect2>

  </sect1>
