<chapter id="scripting">
  <title>Mathematical Expressions and Scripting</title>
  <para>
    Starting with version 0.8.7, QtiPlot supports different interpreters for evaluating mathematical expressions and for executing scripts.
  </para>
  <sect1 id="muParser">
    <title>muParser</title>
    <para>
      The constants _e=e=E and _pi=pi=PI=Pi are defined, as well as the following operators and functions.
    </para>
    <table tocentry="1" pgwide="1" frame="sides">
      <title>Supported Mathematical Operators</title>
      <tgroup cols="2">
	<colspec colname="name" colwidth="1*" align="left"/>
	<colspec colname="description" colwidth="10*" align="justify"/>
	<thead>
	  <row>
	    <entry>Name</entry>
	    <entry>Description</entry>
	  </row>
	</thead>
	<tbody>
	  <row>
	    <entry>+</entry>
	    <entry>Addition</entry>
	  </row>
	  <row>
	    <entry>-</entry>
	    <entry>Substraction</entry>
	  </row>
	  <row>
	    <entry>*</entry>
	    <entry>Multiplication</entry>
	  </row>
	  <row>
	    <entry>/</entry>
	    <entry>Division</entry>
	  </row>
	  <row>
	    <entry>^</entry>
	    <entry>Exponentiation (raise a to the power of b)</entry>
	  </row>
	  <row>
	    <entry>and</entry>
	    <entry>logical and (returns 0 or 1)</entry>
	  </row>
	  <row>
	    <entry>or</entry>
	    <entry>logical or (returns 0 or 1)</entry>
	  </row>
	  <row>
	    <entry>xor</entry>
	    <entry>logical exclusive or (returns 0 or 1)</entry>
	  </row>
	  <row>
	    <entry>&lt;</entry>
	    <entry>less then (returns 0 or 1)</entry>
	  </row>
	  <row>
	    <entry>&lt;=</entry>
	    <entry>less then or equal (returns 0 or 1)</entry>
	  </row>
	  <row>
	    <entry>==</entry>
	    <entry>equal (returns 0 or 1)</entry>
	  </row>
	  <row>
	    <entry>&gt;=</entry>
	    <entry>greater then or equal (returns 0 or 1)</entry>
	  </row>
	  <row>
	    <entry>&gt;</entry>
	    <entry>greater then (returns 0 or 1)</entry>
	  </row>
	  <row>
	    <entry>!=</entry>
	    <entry>not equal (returns 0 or 1)</entry>
	  </row>
	</tbody>
      </tgroup>
    </table>
    <sect2 id="sec-intrinsic-functions">
      <title>Supported Mathematical Functions</title>
      <table tocentry="1" pgwide="1" frame="sides">
	<title>Supported Mathematical Functions</title>
	<tgroup cols="2">
	  <colspec colname="name" colwidth="1*" align="left"/>
	  <colspec colname="description" colwidth="10*" align="justify"/>
	  <thead>
	    <row>
	      <entry>Name</entry>
	      <entry>Description</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>abs(x)</entry>
	      <entry>absolute value of x</entry>
	    </row>
	    <row>
	      <entry>acos(x)</entry>
	      <entry>inverse cosinus</entry>
	    </row>
	    <row>
	      <entry>acosh(x)</entry>
	      <entry>inverse hyperbolic cosinus</entry>
	    </row>
	    <row>
	      <entry>asin(x)</entry>
	      <entry>inverse sinus</entry>
	    </row>
	    <row>
	      <entry>asinh(x)</entry>
	      <entry>inverse hyperbolic sinus</entry>
	    </row>
	    <row>
	      <entry>atan(x)</entry>
	      <entry>inverse tangent</entry>
	    </row>
	    <row>
	      <entry>atanh(x)</entry>
	      <entry>inverse hyperbolic tangent</entry>
	    </row>
	    <row>
	      <entry>avg(x1,x2,x3,...)</entry>
	      <entry>average value, this command accept a list of arguments separated by commas</entry>
	    </row>
	    <row>
	      <entry>bessel_j0(x)</entry>
	      <entry>Regular cylindrical Bessel function of zeroth order, J<subscript>0</subscript>(x).</entry>
	    </row>
	    <row>
	      <entry>bessel_j1(x)</entry>
	      <entry>Regular cylindrical Bessel function of first order, J<subscript>1</subscript>(x).</entry>
	    </row>
	    <row>
	      <entry>bessel_jn(x,n)</entry>
	      <entry>Regular cylindrical Bessel function of n<superscript>th</superscript> order, J<subscript>n</subscript>(x).</entry>
	    </row>
	    <row>
	      <entry>bessel_y0(x)</entry>
	      <entry>Irregular cylindrical Bessel function of zeroth order, Y<subscript>0</subscript>(x) for x&gt;0.</entry>
	    </row>
	    <row>
	      <entry>bessel_y1(x)</entry>
	      <entry>Irregular cylindrical Bessel function of first order, Y<subscript>1</subscript>(x) for x&gt;0.</entry>
	    </row>
	    <row>
	      <entry>bessel_yn(x,n)</entry>
	      <entry>Irregular cylindrical Bessel function of n<superscript>th</superscript> order, Y<subscript>n</subscript>(x) for x>0.</entry>
	    </row>
	    <row>
	      <entry>beta (a,b)</entry>
	      <entry>Computes the Beta Function, B(a,b) = Gamma(a)*Gamma(b)/Gamma(a+b) for a &gt; 0 and b &gt; 0.</entry>
	    </row>
	    <row>
	      <entry>cos(x)</entry>
	      <entry>cosinus of x</entry>
	    </row>
	    <row>
	      <entry>cosh(x)</entry>
	      <entry>hyperbolic cosinus of x</entry>
	    </row>
	    <row>
	      <entry>erf(x)</entry>
	      <entry>error function of x</entry>
	    </row>
	    <row>
	      <entry>erfc(x)</entry>
	      <entry>Complementary error function erfc(x) = 1 - erf(x).</entry>
	    </row>
	    <row>
	      <entry>erfz(x)</entry>
	      <entry>The Gaussian probability density function Z(x).</entry>
	    </row>
	    <row>
	      <entry>erfq(x)</entry>
	      <entry>The upper tail of the Gaussian probability function Q(x).</entry>
	    </row>
	    <row>
	      <entry>exp(x)</entry>
	      <entry>Exponential function: e raised to the power of x.</entry>
	    </row>
	    <row>
	      <entry>gamma(x)</entry>
	      <entry>Computes the Gamma function, subject to x not being a negative integer</entry>
	    </row>
	    <row>
	      <entry>gammaln(x)</entry>
	      <entry>Computes the logarithm of the Gamma function, subject to x not a being negative integer. For x&lt;0, log(|Gamma(x)|) is returned.</entry>
	    </row>
	    <row>
	      <entry>hazard(x)</entry>
	      <entry>Computes the hazard function for the normal distribution h(x) = erfz(x)/erfq(x).</entry>
	    </row>
	    <row>
	      <entry>if(e1,e2,e3)</entry>
	      <entry>if e1 is true, e2 is executed else e3 is executed.</entry>
	    </row>
	    <row>
	      <entry>ln(x)</entry>
	      <entry>natural logarythm of x</entry>
	    </row>
	    <row>
	      <entry>log(x)</entry>
	      <entry>decimal logarythm of x</entry>
	    </row>
	    <row>
	      <entry>log2(x)</entry>
	      <entry>base 2 logarythm of x</entry>
	    </row>
	    <row>
	      <entry>min(x1,x2,x3,...)</entry>
	      <entry>Minimum of the list of arguments</entry>
	    </row>
	    <row>
	      <entry>max(x1,x2,x3,...)</entry>
	      <entry>Maximum of the list of arguments</entry>
	    </row>
	    <row>
	      <entry>rint(x)</entry>
	      <entry>Round to nearest integer.</entry>
	    </row>
	    <row>
	      <entry>sign(x)</entry>
	      <entry>Sign function: -1 if x&lt;0; 1 if x&gt;0.</entry>
	    </row>
	    <row>
	      <entry>sin(x)</entry>
	      <entry>sinus of x</entry>
	    </row>
	    <row>
	      <entry>sinh(x)</entry>
	      <entry>hyperblic sinus of x</entry>
	    </row>
	    <row>
	      <entry>sqrt(x)</entry>
	      <entry>square root of x</entry>
	    </row>
	    <row>
	      <entry>tan(x)</entry>
	      <entry>tangent of x</entry>
	    </row>
	    <row>
	      <entry>tanh(x)</entry>
	      <entry>hyperbolic tangent of x</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>
    </sect2>
  </sect1>
  <sect1 id="Python">
    <title>Python</title>
    <para>
      This module provides bindings to the <ulink url="http://www.python.org">Python</ulink> programming language.
      Basic usage in the context of QtiPlot will be discussed below, but for more in-depth information on the language itself, please refer to its excellent <ulink url="http://www.python.org/doc">documentation</ulink>.
    </para>
    <sect2 id="Python-init">
      <title>The Initialization File</title>
      <para>
	This file allows you to customize the Python environment, import modules and define functions and classes
	that will be available in all of your projects.
	The default initialization file shipped with QtiPlot imports Python's <link linkend="Python-functions">standard
	  math functions</link> as well as special functions from <ulink url="http://www.scipy.org">SciPy</ulink> (if available).
	Also, it creates some handy shortcuts, like <userinput>table(&quot;table1&quot;)</userinput> for
	<userinput>qti.app.table(&quot;table1&quot;)</userinput>.
      </para>
      <para>
	When activating Python support, QtiPlot searches the following places, executing the first file it can find:
      </para>
      <orderedlist>
	<listitem><para>~/.qtiplotrc.py[c]</para></listitem>
	<listitem><para>/etc/qtiplotrc.py[c]</para></listitem>
	<listitem><para>./qtiplotrc.py[c]</para></listitem>
      </orderedlist>
      <para>
	Files ending in .pyc are compiled versions of the .py source files and therefore load a bit faster.
	The compiled version will be used if the source file is older or nonexistent.
	Otherwise, QtiPlot will try to compile the source file (if you've got write permissions for the output file).
      </para>
    </sect2>
    <sect2>
      <title>Python Basics</title>
      <para>
	Mathematical expressions work largely as expected.
	However, there's one caveat, especially when switching from muParser (which has been used exclusively in previous versions of QtiPlot):
	<userinput>a^b</userinput> does not mean &quot;raise a to the power of b&quot; but rather &quot;bitwise exclusive or of a and b&quot;; Python's power operator is **.
	Thus:
	<screen width="40">
	  <userinput>2^3 # read: 10 xor 11 = 01</userinput>
	  <prompt>#> 1</prompt>
	  <userinput>2**3</userinput>
	  <prompt>#> 8</prompt>
	</screen>
      </para>
      <para>
	One thing you have to know when working with Python is that indentation is very important.
	It is used for grouping (most other languages use either braces or keywords like <userinput>do...end</userinput> for this).
	For example,
	<screen width="40">
	  <userinput>x=23</userinput>
	  <userinput>for i in (1,4,5):</userinput>
	  <userinput>	x=i**2</userinput>
	  <userinput>	print(x)</userinput>
	</screen>
	will do what you would expect: it prints out the numbers 1, 16 and 25; each on a line of its own.
	Deleting just a bit of space will change the functionality of your program:
	<screen width="40">
	  <userinput>x=23</userinput>
	  <userinput>for i in (1,4,5):</userinput>
	  <userinput>	x=i**2</userinput>
	  <userinput>print(x)</userinput>
	</screen>
	will print out only one number - no, not 23, but rather 25. This example was designed to also teach you something about variable scoping: There are no block-local variables in Python.
      </para>
      <para>
	There are two different variable scopes to be aware of: local and global variables.
	Unless specified otherwise, variables are local to the context in which they were defined.
	Thus, the variable <varname>x</varname> can have three different values in, say, two different Note windows and a column formula.
	Global variables on the other hand can be accessed from everywhere within your project.
	A variable <varname>x</varname> is declared global by executing the statement <userinput>global x</userinput>.
	You have to do this before assigning a value to <varname>x</varname>, but you have to do it only once within the project (no need to "import" the variable before using it).
	Note that there is a slight twist to these rules when you <link linkend="Python-def">define your own functions</link>.
      </para>
    </sect2>
    <sect2 id="Python-def">
      <title>Defining Functions and Control Flow</title>
      <para>
	The basic syntax for defining a function (for use within one particular note, for example) is
	<screen width="40">
	  <userinput>def answer():</userinput>
	  <userinput>	return 42</userinput>
	</screen>
	If you want your function to be accessible from the rest of your project, you have to declare it global before the definition:
	<screen width="40">
	  <userinput>global answer</userinput>
	  <userinput>def answer():</userinput>
	  <userinput>	return 42</userinput>
	</screen>
	You can add your own function to QtiPlot's function list.
	We'll also provide a documentation string that will show up, for example, in the "set column values" dialog:
	<screen width="40">
	  <userinput>global answer</userinput>
	  <userinput>def answer():</userinput>
	  <userinput>	"Return the answer to the ultimate question about life, the universe and everything."</userinput>
	  <userinput>	return 42</userinput>
	  <userinput>qti.mathFunctions["answer"] = answer</userinput>
	</screen>
	If you want to remove a function from the list, do:
	<screen width="40">
	  <userinput>del qti.mathFunctions["answer"]</userinput>
	</screen>
      </para>
      <para>
	Note that functions have their own local scope.
	That means that if you enter a function definition in a Note, you will not be able to access (neither reading nor writing) Note-local variables from within the function.
	However, you can access global variables as usual.
      </para>
      <para>
	If-then-else decisions are entered as follows:
	<screen width="40">
	  <userinput>if x>23:</userinput>
	  <userinput>	print(x)</userinput>
	  <userinput>else:</userinput>
	  <userinput>	print("The value is too small.")</userinput>
	</screen>
      </para>
      <para>
	You can do loops, too:
	<screen width="40">
	  <userinput>for i in range(1, 11):</userinput>
	  <userinput>	print(i)</userinput>
	</screen>
	This will print out the numbers between 1 and 10 inclusively (the upper limit does not belong to the range, while the lower limit does).
      </para>
    </sect2>
    <sect2 id="Python-functions">
      <title>Mathematical Functions</title>
      <para>
	Python comes with some basic mathematical functions that are automatically imported (if you use the <link linkend="Python-init">initialization file</link> shipped with QtiPlot).
	Along with them, the constants e (Euler's number) and pi (the one and only) are defined.
      </para>
      <table tocentry="1" pgwide="1" frame="sides">
	<title>Supported Mathematical Functions</title>
	<tgroup cols="2">
	  <colspec colname="name" colwidth="1*" align="left"/>
	  <colspec colname="description" colwidth="10*" align="justify"/>
	  <thead>
	    <row>
	      <entry>Name</entry>
	      <entry>Description</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>acos(x)</entry>
	      <entry>inverse cosinus</entry>
	    </row>
	    <row>
	      <entry>asin(x)</entry>
	      <entry>inverse sinus</entry>
	    </row>
	    <row>
	      <entry>atan(x)</entry>
	      <entry>inverse tangent</entry>
	    </row>
	    <row>
	      <entry>atan2(y,x)</entry>
	      <entry>equivalent to atan(y/x), but more efficient</entry>
	    </row>
	    <row>
	      <entry>ceil(x)</entry>
	      <entry>ceiling; smallest integer greater or equal to x</entry>
	    </row>
	    <row>
	      <entry>cos(x)</entry>
	      <entry>cosinus of x</entry>
	    </row>
	    <row>
	      <entry>cosh(x)</entry>
	      <entry>hyperbolic cosinus of x</entry>
	    </row>
	    <row>
	      <entry>degrees(x)</entry>
	      <entry>convert angle from radians to degrees</entry>
	    </row>
	    <row>
	      <entry>exp(x)</entry>
	      <entry>Exponential function: e raised to the power of x.</entry>
	    </row>
	    <row>
	      <entry>fabs(x)</entry>
	      <entry>absolute value of x</entry>
	    </row>
	    <row>
	      <entry>floor(x)</entry>
	      <entry>largest integer smaller or equal to x</entry>
	    </row>
	    <row>
	      <entry>fmod(x,y)</entry>
	      <entry>remainder of integer division x/y</entry>
	    </row>
	    <row>
	      <entry>frexp(x)</entry>
	      <entry>Returns the tuple (mantissa,exponent) such that x=mantissa*(2**exponent) where exponent is an integer and 0.5 &lt;=abs(m)&lt;1.0</entry>
	    </row>
	    <row>
	      <entry>hypot(x,y)</entry>
	      <entry>equivalent to sqrt(x*x+y*y)</entry>
	    </row>
	    <row>
	      <entry>ldexp(x,y)</entry>
	      <entry>equivalent to x*(2**y)</entry>
	    </row>
	    <row>
	      <entry>log(x)</entry>
	      <entry>natural (base e) logarythm of x</entry>
	    </row>
	    <row>
	      <entry>log10(x)</entry>
	      <entry>decimal (base 10) logarythm of x</entry>
	    </row>
	    <row>
	      <entry>modf(x)</entry>
	      <entry>return fractional and integer part of x as a tuple</entry>
	    </row>
	    <row>
	      <entry>pow(x,y)</entry>
	      <entry>x to the power of y; equivalent to x**y</entry>
	    </row>
	    <row>
	      <entry>radians(x)</entry>
	      <entry>convert angle from degrees to radians</entry>
	    </row>
	    <row>
	      <entry>sin(x)</entry>
	      <entry>sinus of x</entry>
	    </row>
	    <row>
	      <entry>sinh(x)</entry>
	      <entry>hyperblic sinus of x</entry>
	    </row>
	    <row>
	      <entry>sqrt(x)</entry>
	      <entry>square root of x</entry>
	    </row>
	    <row>
	      <entry>tan(x)</entry>
	      <entry>tangent of x</entry>
	    </row>
	    <row>
	      <entry>tanh(x)</entry>
	      <entry>hyperbolic tangent of x</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>
    </sect2>
    <sect2 id="Python-API">
      <title>Accessing QtiPlot's functions from Python</title>
      <para>
	We will assume that you are using the <link linkend="Python-init">initialization file</link> shipped with QtiPlot.
      </para>
      <sect3>
	<title>Establishing contact</title>
	<para>
	  Accessing the objects in your project is straight-forward,
	  <screen width="40">
	    <userinput>t = table("table1")</userinput>
	    <userinput>m = matrix("matrix1")</userinput>
	    <userinput>g = graph("graph1")</userinput>
	    <userinput>n = note("Note1")</userinput>
	  </screen>
	  as is creating new objects:
	  <screen width="40">
	    # create an empty table named "tony" with 5 rows and 2 columns:
	    <userinput>t = newTable("tony", 5, 2)</userinput>
	    # use defaults
	    <userinput>t = newTable()</userinput>
	    # create an empty matrix named "gina" with 42 rows and 23 columns:
	    <userinput>m = newMatrix("gina", 42, 23)</userinput>
	    # use defaults
	    <userinput>m = newMatrix()</userinput>
	    # create an empty graph window
	    <userinput>g = newGraph()</userinput>
	    # create an empty note named "momo"
	    <userinput>n = note("momo")</userinput>
	    # use defaults
	    <userinput>n = note()</userinput>
	  </screen>
	</para>
	<para>
	  Also, every piece of code is executed in the context of an object which you can access via the "self" variable.
	  For example, entering <userinput>self.cell("t",i)</userinput> as a column formula is equivalent to the convenience function <userinput>col("t")</userinput>.
	</para>
      </sect3>
      <sect3>
	<title>Working with Tables</title>
	<para>
	  We'll assume that you have assigned some table to the variable <varname>t</varname>.
	  You can access its numeric cell values with
	  <screen width="40">
	    <userinput>t.cell(col, row)</userinput>
	    and
	    <userinput>t.setCell(col, row, value)</userinput>
	  </screen>
	  Whenever you have to specify a column, you can use either the column name (as a string) or the consecutive column number (starting with 1).
	  Row numbers also start with 1, just as they are displayed.
	  If you want to work with arbitrary texts or the textual representations of numeric values, you can use
	  <screen width="40">
	    <userinput>t.text(col, row)</userinput>
	    and
	    <userinput>t.setText(col, row, string)</userinput>
	  </screen>
	  The number of columns and rows is accessed via
	  <screen width="40">
	    <userinput>t.numRows()</userinput>
	    <userinput>t.numCols()</userinput>
	    <userinput>t.setNumRows(number)</userinput>
	    <userinput>t.setNumCols(number)</userinput>
	  </screen>
	  Column names can be read and written with
	  <screen width="40">
	    <userinput>t.colName(number)</userinput>
	    <userinput>t.setColName(col, newName)</userinput>
	  </screen>
	  Normalize a single or all columns:
	  <screen width="40">
	    <userinput>t.normalize(col)</userinput>
	    <userinput>t.normalize()</userinput>
	  </screen>
	  Import values from <varname>file</varname>, using <varname>sep</varname> as separator char and ignoring <varname>ignore</varname> lines at the head of the file.
	  The flags should be self-explanatory.
	  <screen width="40">
	    <userinput>t.importASCII(file, sep="\t", ignore=0, renameCols=False, stripSpaces=True, simplifySpace=False, newTable=False)</userinput>
	  </screen>
	  After having changed some table values from a script, you will likely want to update dependent Graphs:
	  <screen width="40">
	    <userinput>t.notifyChanges()</userinput>
	  </screen>
	</para>
	<para>
	  As a simple example, let's set some column values without using the dialog.
	  <screen width="40">
	    <userinput>t = table("table1")</userinput>
	    <userinput>for i in range(1, t.numRows()+1):</userinput>
	    <userinput>	t.setCell(1, i, i**2)</userinput>
	    <userinput>t.notifyChanges()</userinput>
	  </screen>
	</para>
      </sect3>
      <sect3>
	<title>Working with Matrices</title>
	<para>
	  We'll assume that you have assigned some matrix to the variable <varname>m</varname>.
	  Accessing cell values is very similar to Table, but since Matrix doesn't use column logic, row arguments are specified before columns and obviously you can't use column name.
	  <screen width="40">
	    <userinput>m.cell(row, col)</userinput>
	    <userinput>m.setCell(row, col, value)</userinput>
	    <userinput>m.text(row, col)</userinput>
	    <userinput>m.setText(row, col, string)</userinput>
	  </screen>
	  Also like with tables, there's
	  <screen width="40">
	    <userinput>m.numRows()</userinput>
	    and
	    <userinput>m.numCols()</userinput>
	  </screen>
	</para>
      </sect3>
      <sect3>
	<title>Plotting and Working with Graphs</title>
	<para>
	  If you want to create a new Graph window for some data in table table1, you can use the plot command:
	  <screen width="40">
	    <userinput>g = plot(table, column, type)</userinput>
	  </screen>
	  <varname>type</varname> is a number between 0 and 10 and specifies the desired plot type:
	  <variablelist spacing="compact">
	    <varlistentry><term>0.</term><listitem><para>Line</para></listitem></varlistentry>
	    <varlistentry><term>1.</term><listitem><para>Symbols</para></listitem></varlistentry>
	    <varlistentry><term>2.</term><listitem><para>Line and Symbols</para></listitem></varlistentry>
	    <varlistentry><term>3.</term><listitem><para>Columns</para></listitem></varlistentry>
	    <varlistentry><term>4.</term><listitem><para>Area</para></listitem></varlistentry>
	    <varlistentry><term>5.</term><listitem><para>Pie</para></listitem></varlistentry>
	    <varlistentry><term>6.</term><listitem><para>Vertical drop lines</para></listitem></varlistentry>
	    <varlistentry><term>7.</term><listitem><para>Splines and Symbols</para></listitem></varlistentry>
	    <varlistentry><term>8.</term><listitem><para>Vertical steps</para></listitem></varlistentry>
	    <varlistentry><term>9.</term><listitem><para>Histogram</para></listitem></varlistentry>
	    <varlistentry><term>10.</term><listitem><para>Rows</para></listitem></varlistentry>
	  </variablelist>
	  You can plot more than one column at once by giving a Python tuple (see the <ulink url="http://docs.python.org/tut">Python Tutorial</ulink>) as an argument:
	  <screen width="40">
	    <userinput>g = plot(table("table1"), (2,4,7), 2)</userinput>
	  </screen>
	</para>
	<para>
	  If you want to add a curve to an existing Graph window, you have to choose the destination layer.
	  Usually,
	  <screen width="40">
	    <userinput>l = g.activeLayer()</userinput>
	  </screen>
	  will do the trick, but you can also select a layer by its number:
	  <screen width="40">
	    <userinput>l = g.layer(num)</userinput>
	  </screen>
	  You can then add or remove curves to or from this layer:
	  <screen width="40">
	    <userinput>l.insertCurve(table, column, type=1)</userinput>
	    <userinput>l.insertCurve(table, Xcolumn, Ycolumn, type=1)</userinput>
	    <userinput>l.removeCurve(curveName)</userinput>
	    <userinput>l.removeCurve(curveNumber)</userinput>
	    <userinput>l.deleteFitCurves()</userinput>
	  </screen>
	  In case you need the number of curves on a layer, you can get it with
	  <screen width="40">
	    <userinput>l.numCurves()</userinput>
	  </screen>
	</para>
	<para>
	  Layers and whole Graphs can be printed and exported from within Python.
	  Before you do this, you probably want to change layer and axis titles as well as legend texts:
	  <screen width="40">
	    <userinput>l.setTitle(title)</userinput>
	    <userinput>l.setXTitle(Xtitle)</userinput>
	    <userinput>l.setYTitle(Ytitle)</userinput>
	    <userinput>l.setLegend(text)</userinput>
	  </screen>
	  Now, here is how you can export a layer
	  <screen width="40">
	    <userinput>l.print()</userinput>
	    <userinput>l.exportToSVG(filename)</userinput>
	    <userinput>l.exportToEPS(filename)</userinput>
	    <userinput>l.exportToWMF(filename)</userinput>
	    <userinput>l.exportImage(filename, filetype="PNG", quality=100, transparent=False)</userinput>
	  </screen>
	  and a graph
	  <screen width="40">
	    <userinput>g.print()</userinput>
	    <userinput>g.exportToSVG(filename)</userinput>
	    <userinput>g.exportToEPS(filename)</userinput>
	  </screen>
	</para>
      </sect3>
      <sect3>
	<title>Fitting</title>
	<para>
	  Assuming you have a Graph named "graph1" with a curve entitled "table1_2" (on its active layer), a minimal Fit example would be:
	  <screen width="40">
	    <userinput>f = GaussFit(graph("graph1").activeLayer(), "table1_2")</userinput>
	    <userinput>f.guessInitialValues()</userinput>
	    <userinput>f.fit()</userinput>
	  </screen>
	  This creates a new GaussFit object on the curve, lets it guess the start parameters and does the fit.
	  The following fit types are supported:
	  <itemizedlist>
	    <listitem><para>LinearFit(layer, curve)</para></listitem>
	    <listitem><para>PolynomialFit(layer, curve, degree=2, legend=False)</para></listitem>
	    <listitem><para>ExponentialFit(layer, curve, growth=False)</para></listitem>
	    <listitem><para>TwoExpFit(layer, curve)</para></listitem>
	    <listitem><para>ThreeExpFit(layer, curve)</para></listitem>
	    <listitem><para>GaussFit(layer, curve)</para></listitem>
	    <listitem><para>GaussAmpFit(layer, curve)</para></listitem>
	    <listitem><para>LorentzFit(layer,curve)</para></listitem>
	    <listitem><para>SigmoidalFit(layer, curve)</para></listitem>
	    <listitem><para>NonLinearFit(layer, curve)</para></listitem>
	    <listitem><para>PluginFit(layer, curve)</para></listitem>
	  </itemizedlist>
	  For each of these, you can optionally restrict the X range that will be used for the fit, like in
	  <screen width="40">
	    <userinput>f = LinearFit(graph("graph1").activeLayer(), "table1_2", 2, 7)</userinput>
	    <userinput>f.fit()</userinput>
	  </screen>
	</para>
	<para>
	  After creating the Fit object and before calling its fit() method, you can set a number of parameters that influence the fit:
	  <screen width="40">
	    <userinput>f.setDataFromCurve(curve) # change data source</userinput>
	    <userinput>f.setDataFromCurve(curve, graph) # change data source</userinput>
	    <userinput>f.setDataFromCurve(curve, from, to) # change data source</userinput>
	    <userinput>f.setDataFromCurve(curve, from, to, graph) # change data source</userinput>
	    <userinput>f.setInterval(from, to) # change data range</userinput>
	    <userinput>f.setInitialValue(number, value)</userinput>
	    <userinput>f.setInitialValues(value1, ...)</userinput>
	    <userinput>f.guessInitialValues()</userinput>
	    <userinput>f.setAlgorithm(algo) # algo = Fit.ScaledLevenbergMarquardt, Fit.UnscaledLevenbergMarquardt, Fit.NelderMeadSimplex</userinput>
	    <userinput>f.setWeightingData(method, colname) # method = Fit.NoWeighting, Fit.Instrumental, Fit.Statistical, Fit.ArbDataset</userinput>
	    <userinput>f.setTolerance(tolerance)</userinput>
	    <userinput>f.setOutputPrecision(precision)</userinput>
	    <userinput>f.setMaximumIterations(number)</userinput>
	  </screen>
	</para>
	<para>
	  After you've called fit(), you have a number of possibilities for extracting the results:
	  <screen width="40">
	    <userinput>f.results()</userinput>
	    <userinput>f.errors()</userinput>
	    <userinput>f.chiSquare()</userinput>
	    <userinput>f.parametersTable("params").show()</userinput>
	    <userinput>f.covarianceMatrix("cov").show()</userinput>
	  </screen>
	</para>
      </sect3>
    </sect2>
  </sect1>
</chapter>

